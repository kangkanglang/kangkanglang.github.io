<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>HTTPS知识积累</title>
    <link href="/2020/08/15/HTTPS/"/>
    <url>/2020/08/15/HTTPS/</url>
    
    <content type="html"><![CDATA[<p>HTTPS相关知识小结，欢迎交流，指证错误。</p><a id="more"></a><h2 id="1-HTTP协议中所存在的问题"><a href="#1-HTTP协议中所存在的问题" class="headerlink" title="1. HTTP协议中所存在的问题"></a>1. HTTP协议中所存在的问题</h2><blockquote><ul><li>数据是明文传输，容易被窃听截取</li><li>数据的完整性未校验，容易被篡改</li><li>没有验证对方身份，存在冒充危险</li></ul></blockquote><h2 id="2-HTTPS协议"><a href="#2-HTTPS协议" class="headerlink" title="2. HTTPS协议"></a>2. HTTPS协议</h2><p>为了解决上述HTTP存在的问题，就用到了HTTPS。</p><blockquote><p>HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：可以理解为HTTP+SSL/TLS， 即 HTTP 下加入 SSL（Secure Socket Layer，安全套接字层）层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL，用于安全的 HTTP 数据传输。</p></blockquote><p>如下图所示： HTTPS 相比 HTTP 多了一层 SSL/TLS</p><p><img src="https://gitee.com/yuanlu_k/BlogImages/raw/master/Https/https_ssl.png" srcset="/img/loading.gif" alt="HTTPS SSL/TLS"></p><h3 id="2-1-加密算法"><a href="#2-1-加密算法" class="headerlink" title="2.1. 加密算法"></a>2.1. 加密算法</h3><ul><li><p>对称加密</p><ul><li>即加密的密钥和解密的密钥相同</li><li>优点：计算量小、加密速度快、加密效率高。</li><li>缺点:（1）交易双方都使用同样密钥，安全性得不到保证；（2）每次使用对称加密算法时，都需要使用其他人不知道的惟一密钥，这会使得发收信息双方所拥有的钥匙数量呈几何级数增长，密钥管理成为负担。</li></ul></li><li><p>非对称加密</p><ul><li>非对称加密将密钥分为公钥和私钥,公钥可以公开,私钥需要保密。</li><li>使用公钥对数据进行加密，可以用私钥解密得到数据；也可以使用私钥对数据进行加密，公钥解密得到数据。</li><li>但一般使用公钥加密，私钥解密。</li><li>优点：非对称加密相比对称加密更加安全</li><li>缺点：（1）CPU计算资源消耗非常大；（2）非对称加密算法对加密内容的长度有限制，不能超过公钥长度。比如现在常用的公钥长度是2048位，意味着待加密内容不能超过256个字节。</li></ul></li></ul><h3 id="2-2-建立连接"><a href="#2-2-建立连接" class="headerlink" title="2.2. 建立连接"></a>2.2. 建立连接</h3><ul><li>HTTP和HTTPS<strong><em>都需要在建立连接的基础上来进行数据传输</em></strong>,是基本操作</li><li>当客户在浏览器中输入网址的并且按下回车,浏览器会在浏览器DNS缓存,本地DNS缓存,和Hosts中寻找对应的记录,如果没有获取到则会请求DNS服务来获取对应的IP</li><li>当获取到IP后,TCP连接会进行三次握手建立连接</li></ul><h3 id="2-3-TCP的三次握手和四次挥手"><a href="#2-3-TCP的三次握手和四次挥手" class="headerlink" title="2.3. TCP的三次握手和四次挥手"></a>2.3. TCP的三次握手和四次挥手<a href="TCP和UDP详解"></a></h3><p>过程简图如下所示：</p><p><img src="https://gitee.com/yuanlu_k/BlogImages/raw/master/Https/TCP%E8%BF%9E%E6%8E%A5.png" srcset="/img/loading.gif" alt="三次握手和四次挥手"></p><blockquote><p><strong><em>三次握手（建立连接）</em></strong></p><ul><li>第一次：建立连接时，客户端发送SYN包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；</li><li>第二次：服务器收到SYN包，向客户端返回ACK（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RCVD状态；</li><li>第三次：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</li><li>完成三次握手，客户端与服务器开始传送数据，也就是ESTABLISHED状态。</li><li>三次握手保证了不会建立无效的连接，从而浪费资源。</li></ul></blockquote><blockquote><p><strong><em>四次挥手（释放连接）</em></strong></p><ul><li>第一次：TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送。</li><li>第二次：服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。</li><li>第三次：服务器关闭客户端的连接，发送一个FIN给客户端。</li><li>第四次：客户端发回ACK报文确认，并将确认序号设置为收到序号加1。</li></ul></blockquote><h3 id="2-4-HTTPS请求"><a href="#2-4-HTTPS请求" class="headerlink" title="2.4. HTTPS请求"></a>2.4. HTTPS请求</h3><p>在TCP连接建立之后，HTTPS请求过程如下图所示：</p><p><img src="https://gitee.com/yuanlu_k/BlogImages/raw/master/Https/HTTPS.png" srcset="/img/loading.gif" alt="HTTPS请求"></p><blockquote><p>①发送客户端支持的加密协议及版本，非对称加密算法，随机数1</p><p>②服务端筛选加密协议，对称算法，随机数2，证书（License）</p><p>③客户端先从 CA 验证该证书的合法性，验证通过后取出证书中的服务端公钥</p><p>④生成随机数3，再用服务端公钥非对称加密随机数3，生成 PreMaster Key</p><p>⑤服务端依据私钥解密PreMaster Key，得出随机数3</p><p>⑥至此，客户端和服务端都有了三个随机数，再依据相同的算法生成对称加密的密钥</p><p>⑦客户端和服务端开始使用对称加密后的密文进行通信。</p></blockquote><h3 id="2-5-HTTPS的缺点"><a href="#2-5-HTTPS的缺点" class="headerlink" title="2.5. HTTPS的缺点"></a>2.5. HTTPS的缺点</h3><ul><li>HTTPS协议多次握手，导致页面的加载时间延长近50%；</li><li>HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗；</li><li>申请SSL证书需要钱，功能越强大的证书费用越高。</li><li>SSL涉及到的安全算法会消耗 CPU 资源，对服务器资源消耗较大。</li></ul><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><ul><li>HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的；HTTPS使用了SSL/TLS协议进行了加密处理。</li><li>HTTPS和HTTP使用连接方式不同，默认端口也不一样，HTTP是80，HTTPS是443。</li><li>HTTPS中在请求过程中使用非对称加密技术，而在通信过程中使用的是对称加密技术。</li><li>HTTPS需要非对称加密 、 对称加密 和 CA 共同实现。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTPS</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo编写博客教程</title>
    <link href="/2020/08/15/Hexo%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/08/15/Hexo%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>这是我的第一篇博客，包含Hexo的基本使用，是一篇测试博客。</p><a id="more"></a><p>欢迎来到<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! 这是我编写的第一个博客。你可以通过查看<a href="https://hexo.io/docs/" target="_blank" rel="noopener">文档</a>来获取等多的信息。如果在使用Hexo过程中遇到任何为题，你可以通过<a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a>寻找解决方法，或者你可以在<a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>上向我提问。</p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>欢迎来到<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! 这是我编写的第一个博客。你可以通过查看<a href="https://hexo.io/docs/" target="_blank" rel="noopener">文档</a>来获取等多的信息。如果在使用Hexo过程中遇到任何为题，你可以通过<a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a>寻找解决方法，或者你可以在<a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>上向我提问。</p><h2 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h2><p>欢迎来到<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! 这是我编写的第一个博客。你可以通过查看<a href="https://hexo.io/docs/" target="_blank" rel="noopener">文档</a>来获取等多的信息。如果在使用Hexo过程中遇到任何为题，你可以通过<a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a>寻找解决方法，或者你可以在<a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>上向我提问。</p><h2 id="快速入门-2"><a href="#快速入门-2" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="创建一个post-播客页面"><a href="#创建一个post-播客页面" class="headerlink" title="创建一个post(播客页面)"></a>创建一个post(播客页面)</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>更过<a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">博客编写信息</a>。</p><h3 id="启动Hexo-Server"><a href="#启动Hexo-Server" class="headerlink" title="启动Hexo Server"></a>启动Hexo Server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>有关<a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a>更多信息。</p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>关于<a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a>更多信息。</p><h3 id="部署到服务器站点"><a href="#部署到服务器站点" class="headerlink" title="部署到服务器站点"></a>部署到服务器站点</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>关于<a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a>更多信息。</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning</tag>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java GC 知识小结</title>
    <link href="/2020/08/15/Java-GC%E5%B0%8F%E7%BB%93/"/>
    <url>/2020/08/15/Java-GC%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>Java GC相关知识小结，欢迎交流，指证错误。</p><a id="more"></a><h1 id="1-什么是垃圾？怎么寻找垃圾？"><a href="#1-什么是垃圾？怎么寻找垃圾？" class="headerlink" title="1. 什么是垃圾？怎么寻找垃圾？"></a>1. 什么是垃圾？怎么寻找垃圾？</h1><h2 id="1-1-什么是垃圾？"><a href="#1-1-什么是垃圾？" class="headerlink" title="1.1. 什么是垃圾？"></a>1.1. 什么是垃圾？</h2><blockquote><p><em>不再被引用的对象称为垃圾。</em></p></blockquote><h2 id="1-2-垃圾寻找方法（垃圾标记方法）："><a href="#1-2-垃圾寻找方法（垃圾标记方法）：" class="headerlink" title="1.2 . 垃圾寻找方法（垃圾标记方法）："></a>1.2 . 垃圾寻找方法（垃圾标记方法）：</h2><h3 id="1-2-1-引用计数算法（Reference-Counting）："><a href="#1-2-1-引用计数算法（Reference-Counting）：" class="headerlink" title="1.2.1.  引用计数算法（Reference Counting）："></a>1.2.1.  引用计数算法（Reference Counting）：</h3><p>介绍：给对象添加一个引用计数器，每当一个地方引用它时，计数器加1；当引用失效时，计数器减1；计数器为0的即可被回收。</p><blockquote><p>优点：实现简单，判断效率高。<br>缺点：存在循环引用（objA.instance = objB; objB.instance = objA）的问题，所以Java语言并没有选用引用计数法管理内存。</p></blockquote><h3 id="1-2-2-根搜索算法（GC-Root-Searching）"><a href="#1-2-2-根搜索算法（GC-Root-Searching）" class="headerlink" title="1.2.2. 根搜索算法（GC Root Searching）"></a>1.2.2. 根搜索算法（GC Root Searching）</h3><p>Java和C#都是使用根搜索算法来判断对象是否存活。通过一系列的名为“GC Root”的对象作为起始点，从这些节点开始向下搜索，搜索所有走过的路径称为引用链（Reference Chain）,当一个对象到GC Root没有任何引用链相连时（用图论来说就是GC Root到这个对象不可达时），证明该对象是可以被回收的。</p><blockquote><p>不存在循环引用问题。</p></blockquote><blockquote><p>在Java中哪些对象可以成为GC Root?</p><ul><li>虚拟机栈（栈帧中的本地变量表）中的引用对象</li><li>方法区中的类静态属性引用的对象</li><li>方法区中的常量引用对象</li><li>本地方法栈中JNI（即Native方法）的引用对象</li></ul></blockquote><h1 id="2-常见的垃圾收集算法有哪些？"><a href="#2-常见的垃圾收集算法有哪些？" class="headerlink" title="2. 常见的垃圾收集算法有哪些？"></a>2. 常见的垃圾收集算法有哪些？</h1><h2 id="2-1-标记清除-Mark-sweep"><a href="#2-1-标记清除-Mark-sweep" class="headerlink" title="2.1 标记清除(Mark-sweep)"></a>2.1 标记清除(Mark-sweep)</h2><p>这是垃圾收集算法中最基础的，根据名字就可以知道，它的思想就是标记那些要被回收的对象，然后统一回收。这种方法很简单，但是会有两个主要问题：</p><blockquote><ul><li>效率不高，标记和清除的效率都很低；</li><li>会产生大量不连续的内存碎片，导致以后程序在分配交大的对象时，由于没有充足的连续内存而提前触发一次GC动作。</li></ul></blockquote><h2 id="2-2-复制算法-Copying"><a href="#2-2-复制算法-Copying" class="headerlink" title="2.2. 复制算法(Copying)"></a>2.2. 复制算法(Copying)</h2><p>为了解决效率问题，复制算法将可用内存按容量划分相等的两部分，然后每次只使用其中的一块，当第一块内存用完时，就将还存活的对象复制到第二块内存上，然后一次性清除完第一块内存，在将第二块上的对象复制到第一块。但是这种方式，<strong>内存的代价太高，每次基本上都要浪费一块内存。</strong><br>于是将该算法进行了改进，内存区域不再是按照1：1去划分，而是将内存划分为8：1：1三部分，较大的那份内存叫Eden区，其余两块较小的内存叫Survior区。每次都会先使用Eden区，若Eden区满了，就将对象赋值到Survivor区上，然后清除Eden区，如果此时存活的对象太多，以至于Survivor不够时，会将这些对象通过分配担保机制赋值到老年代中。（Java堆又分为新生代和老年代）。</p><h2 id="2-3-标记-整理算法-Mark-Compact"><a href="#2-3-标记-整理算法-Mark-Compact" class="headerlink" title="2.3. 标记-整理算法(Mark-Compact)"></a>2.3. 标记-整理算法(Mark-Compact)</h2><p>该算法是为了<strong>解决标记-清除，产生大量内存碎片的问题</strong>；当对象存活率较高时，也解决了复制算法的效率问题。它的不同之处就是在清除对象的时候现将可回收的对象移动一端，然后清除掉端边界以外的对象，这样就不会产生内存碎片。</p><h2 id="2-4-分代收集算法（Generational-Collection）"><a href="#2-4-分代收集算法（Generational-Collection）" class="headerlink" title="2.4. 分代收集算法（Generational Collection）"></a>2.4. 分代收集算法（Generational Collection）</h2><p>根据对象的存活周期的不同将内存划分为几块，一般就分为新生代和老年代，根据各个年代的特点采用不同的收集算法。新生代（少量存活）用”复制算法“；老年代（对象存活率高）“标记-清除算法”。</p><h1 id="3-Java内存模型"><a href="#3-Java内存模型" class="headerlink" title="3. Java内存模型"></a>3. Java内存模型</h1><p>内存模型如下图所示：</p><p><img src="https://gitee.com/yuanlu_k/BlogImages/raw/master/Java-GC%E5%B0%8F%E7%BB%93/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" srcset="/img/loading.gif" alt="Java内存模型"></p><h2 id="3-1-堆"><a href="#3-1-堆" class="headerlink" title="3.1. 堆"></a>3.1. 堆</h2><ul><li>堆是Java虚拟机所管理的内存最大一块。堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域唯一的目的就是存放对象实例。所有的对象实例都在这里分配内存。<br>堆内存分为年轻代（Young Generation）、老年代（Old Generation），年轻代又分为Eden区和Survivor区。Survivor区由FromSpace和ToSpace组成。Eden区占大容量，Survivor两个区占小容量，默认比例是8:1:1。</li><li><strong>Java堆是垃圾收集器管理的主要区域。</strong></li><li>从内存回收的角度来看，由于现在的垃圾收集器采用的是分代收集算法。所以，Java堆又分为新生代和老年代。</li><li>从内存分配的角度来说，线程共享的Java堆中可能划分出多个线程私有的fenp缓冲区(Thread Local Allocation Buffer)。</li><li>可以通过 -Xms、-Xmx分别控制堆初始化是最小堆内存和最大堆内存大小</li></ul><h2 id="3-2-虚拟机栈"><a href="#3-2-虚拟机栈" class="headerlink" title="3.2. 虚拟机栈"></a>3.2. 虚拟机栈</h2><ul><li>与程序计数器一样，Java虚拟机栈也是线程私有的，他的生命周期与线程相同。</li><li>虚拟机栈描述的是Java方法的执行的内存模型：每个方法在执行的同时会创建一个栈桢（stack frame）用于存储<strong>局部变量表、操作数栈、动态链表、方法出口等信息</strong>。每个方法从调用直至执行完成的过程，就对应着栈桢在虚拟机栈中入栈到出栈的过程。</li><li>在虚拟机规范中，对这个区域规定了两种异常情况：StackOverflowError 和 OutOfMemorryError</li></ul><h2 id="3-3-本地方法栈"><a href="#3-3-本地方法栈" class="headerlink" title="3.3. 本地方法栈"></a>3.3. 本地方法栈</h2><ul><li>与虚拟机栈发挥的作用非常类似，他们之间的区别是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的native方法服务。与虚拟机栈一样，本地方法区栈也会抛出StackOverflowError，OutOfMemorryError异常。</li></ul><h2 id="3-4-方法区（1-8后该区域被废弃）"><a href="#3-4-方法区（1-8后该区域被废弃）" class="headerlink" title="3.4. 方法区（1.8后该区域被废弃）"></a>3.4. 方法区（1.8后该区域被废弃）</h2><ul><li>方法区与Java堆一样，是各个线程所共享的，它用来存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</li><li>方法区是jvm提出的规范，而永久代就是方法区的具体实现。</li><li>Java虚拟机对方法区的限制非常宽松，可以像堆一样不需要连续的内存可可选择的固定大小外，还可以选择不识闲垃圾收集，相对而言，垃圾收集行为在这边区域是比较少出现的。</li><li>在方法区会报出 永久代内存溢出的错误。而Java1.8为了解决这个问题，就提出了meta space（元空间）的概念，就是为了解决永久代内存溢出的情况，一般来说，在不指定 meta space大小的情况下，虚拟机方法区内存大小就是宿主主机的内存大小.</li></ul><h2 id="3-5-程序计数器"><a href="#3-5-程序计数器" class="headerlink" title="3.5. 程序计数器"></a>3.5. 程序计数器</h2><ul><li>程序计数器是一块较小的内存空间，他可以看做是当前线程所执行字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选择下一条将要执行的字节码指令。</li><li>由于JAVA虚拟机的多线程是通过多线程流转切换并分配处理器执行时间的方式来实现的。<strong>在任一一个确定的时刻，一个处理器都只会执行一条线程中的指令</strong>。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各个线程的计数器之间互不影响，独立存储，我们称该类内存区域为线程私有。</li><li>如果线程正在执行一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址。</li></ul><h2 id="3-6-运行时常量池"><a href="#3-6-运行时常量池" class="headerlink" title="3.6. 运行时常量池"></a>3.6. 运行时常量池</h2><ul><li>运行时常量池是方法区的一部分。Class文件除了有类的版本、字段、方法、接口等描述信息外，还有一项是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容在类加载后进入方法区的运行时常量池。</li><li>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性。Java语言并不要求常量一定只有在编译器才能产生，依旧是并非预置入Class文件中的常量池的内容才能进入方法区运行时常量池。</li></ul><h1 id="4-Java-GC的过程。"><a href="#4-Java-GC的过程。" class="headerlink" title="4. Java GC的过程。"></a>4. Java GC的过程。</h1><p><img src="https://gitee.com/yuanlu_k/BlogImages/raw/master/Java-GC%E5%B0%8F%E7%BB%93/javaGC%E8%BF%87%E7%A8%8B.png" srcset="/img/loading.gif" alt="Java GC过程"></p><blockquote><p>1、先判断创建的对象是否可以放入栈中，若可以的话，直接放入栈中，对象使用完后，直接从栈中pop即可，不涉及GC。<br>2、若不能放入栈中，判断对象所占内存是否太大，若对象太大，则直接放入堆中的老年代，最后通过FGC（Full GC）进行回收。<br>3、对象所占内存不算太大，经过TLAB（Thread Local Allocation Buffer）后放入Eden区。<br>4、在Eden区经过GC后，放入Survior1。<br>5、在Survior1中经历GC时，判断年龄是否太大，太大则将对象放入老年区。<br>6、年龄不大，则进入Survior2。<br>7、在Survior2中经历GC时，判断年龄是否太大，太大则将对象放入老年区。<br>8、年龄不大，则进入Survior1。<br>9、重复 5~8 。</p></blockquote><h1 id="5-垃圾回收所有算法。"><a href="#5-垃圾回收所有算法。" class="headerlink" title="5. 垃圾回收所有算法。"></a>5. 垃圾回收所有算法。</h1><blockquote><p>除Epsilon ZGC Shenandoah之外的GC都是使用逻辑分代模型<br>G1是逻辑分代，物理不分代<br>除此之外不仅逻辑分代，而且物理分代</p></blockquote><p><img src="https://gitee.com/yuanlu_k/BlogImages/raw/master/Java-GC%E5%B0%8F%E7%BB%93/allGC%E7%AE%97%E6%B3%95.png" srcset="/img/loading.gif" alt="所有GC算法"></p><p>上图是10种常见的垃圾回收算法。画弧线部分表示可以组合使用，图中黄线部分是最常见的3种组合。（<strong>STW ： Stop The World 非常严重的问题</strong>）</p><h2 id="5-1-Serial。"><a href="#5-1-Serial。" class="headerlink" title="5.1. Serial。"></a>5.1. Serial。</h2><p>在GC时，由单线程进行“清理”，其他线程（业务线程等）全部停止（STW）。</p><p><img src="https://gitee.com/yuanlu_k/BlogImages/raw/master/Java-GC%E5%B0%8F%E7%BB%93/Serial.png" srcset="/img/loading.gif" alt="Serial模型"></p><h2 id="5-2-Parallel-Scaven。"><a href="#5-2-Parallel-Scaven。" class="headerlink" title="5.2. Parallel Scaven。"></a>5.2. Parallel Scaven。</h2><p>在GC时由多线程进行“清理”，  其他线程（业务线程等）全部停止（STW）。  </p><p><img src="https://gitee.com/yuanlu_k/BlogImages/raw/master/Java-GC%E5%B0%8F%E7%BB%93/ParallelScaven.png" srcset="/img/loading.gif" alt="Parallel Scaven模型"></p><h2 id="5-3-Serial-Old。"><a href="#5-3-Serial-Old。" class="headerlink" title="5.3. Serial Old。"></a>5.3. Serial Old。</h2><p>用于老年代收集垃圾的单线程GC。</p><p><img src="https://gitee.com/yuanlu_k/BlogImages/raw/master/Java-GC%E5%B0%8F%E7%BB%93/SerialOld.png" srcset="/img/loading.gif" alt="Serial Old模型"></p><h2 id="5-4-ParNew。"><a href="#5-4-ParNew。" class="headerlink" title="5.4. ParNew。"></a>5.4. ParNew。</h2><p>与Parallel Scaven类似，但它可以与CMS配合使用。</p><p><img src="http://gitee.com/yuanlu_k/BlogImages/raw/master/Java-GC%E5%B0%8F%E7%BB%93/ParNew.png" srcset="/img/loading.gif" alt="ParNew模型"></p>]]></content>
    
    
    <categories>
      
      <category>Java learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LRU算法的实现</title>
    <link href="/2020/08/15/LRU/"/>
    <url>/2020/08/15/LRU/</url>
    
    <content type="html"><![CDATA[<p>LRU算法的实现，欢迎交流，指证错误。</p><a id="more"></a><p>LRU是Least Recently Used的缩写，即最近最少使用，常用于页面置换算法，是为虚拟页式存储管理服务的。</p><blockquote><p>LRU 算法的<strong><em>设计原则</em></strong>是：如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。也就是说，当限定的空间已存满数据时，应当把最久没有被访问到的数据淘汰。</p></blockquote><h3 id="实现方案："><a href="#实现方案：" class="headerlink" title="实现方案："></a>实现方案：</h3><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Deque;<span class="hljs-keyword">import</span> java.util.HashMap;<span class="hljs-keyword">import</span> java.util.LinkedList;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-comment">/**</span><span class="hljs-comment"> * LRU 手动实现</span><span class="hljs-comment"> * LRU 每次淘汰最近最少使用的缓存value</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 思路：</span><span class="hljs-comment"> * 1、用HashMap作为缓存，实现添加缓存值和更新值</span><span class="hljs-comment"> * 2、通过一个双向链表记录缓存值的使用记录， 最近有使用的放入表头，最近最少使用的放在表尾</span><span class="hljs-comment"> * 3、HashMap中 key 即为搜索查询使用的 key ； value 是双向链表的结点 node</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Deque&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;Node&gt;();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span></span>&#123;        <span class="hljs-keyword">int</span> key;        <span class="hljs-keyword">int</span> value;        Node pre;        Node next;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">()</span></span>&#123;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span></span>&#123;            <span class="hljs-keyword">this</span>.key = key;            <span class="hljs-keyword">this</span>.value = value;        &#125;    &#125;    <span class="hljs-keyword">private</span> Map&lt;Integer, Node&gt; cache = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;    <span class="hljs-keyword">private</span> Node head, tail;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span></span>&#123;        <span class="hljs-keyword">this</span>.capacity = capacity;        <span class="hljs-keyword">this</span>.count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">this</span>.head = <span class="hljs-keyword">new</span> Node();        <span class="hljs-keyword">this</span>.tail = <span class="hljs-keyword">new</span> Node();        head.pre = <span class="hljs-keyword">null</span>;        head.next = tail;        tail.pre = head;        tail.next = <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 从缓存中取值</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 取值的key</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 若key所对应的值存在则返回，否则返回-1</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span></span>&#123;        Node node = cache.get(key);        <span class="hljs-keyword">if</span>(node != <span class="hljs-keyword">null</span>)&#123;            moveToHead(node);            <span class="hljs-keyword">return</span> node.value;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 往缓存中添加（更新）值</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 值对的key</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 缓存值</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span></span>&#123;        Node node = cache.get(key);        <span class="hljs-comment">// 未在缓存中，添加至缓存</span>        <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>)&#123;            node = <span class="hljs-keyword">new</span> Node(key, value);            cache.put(key, node);            addNode(node);            ++count;            <span class="hljs-keyword">if</span>(count &gt; capacity)&#123; <span class="hljs-comment">//超出容量</span>                popTail();                --count;            &#125;        &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 在缓存中， 更新缓存值</span>            node.value = value;            moveToHead(node);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 将链表中最后一个节点移除。同时也从缓存中移除</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">popTail</span><span class="hljs-params">()</span> </span>&#123;        Node node = tail.pre;        removeNode(node);        cache.remove(node.key);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 将节点移动至链表的头部，表示该节点刚添加 或 刚更新 。</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> node 节点</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">moveToHead</span><span class="hljs-params">(Node node)</span> </span>&#123;        removeNode(node);        addNode(node);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 添加节点</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> node 节点</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNode</span><span class="hljs-params">(Node node)</span> </span>&#123;        node.pre = head;        node.next = head.next;        head.next = node;        node.next.pre = node;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 移除指定节点</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> node 节点</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeNode</span><span class="hljs-params">(Node node)</span> </span>&#123;        node.pre.next = node.next;        node.next.pre = node.pre;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LRU</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 索引（一）B-/+树</title>
    <link href="/2020/08/15/MySQL%E7%B4%A2%E5%BC%95B+%E6%A0%91/"/>
    <url>/2020/08/15/MySQL%E7%B4%A2%E5%BC%95B+%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>MySQL索引相关知识小结，欢迎交流，指证错误。</p><a id="more"></a><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>MyISAM和InnoDB是MySQL最常用的两个存储引擎，本文将进行详尽的介绍和对比。</p><p>本文会图解两种引擎的索引结构区别，然后讲解索引的原理，理解本文内容，就能够理解索引优化的各种原则的背后原因。</p><blockquote><p>B-树、B树和B-tree是同一个数据结构。</p><p>MyISAM和InnoDB的索引均采用B+树数据结构，所以接下来先介绍一下B树与B+树。</p></blockquote><h2 id="1-B树和B-树"><a href="#1-B树和B-树" class="headerlink" title="1. B树和B+树"></a>1. B树和B+树</h2><h3 id="1-1-B树"><a href="#1-1-B树" class="headerlink" title="1.1. B树"></a>1.1. B树</h3><blockquote><p><strong><em>B树是一种多路搜索树。</em></strong></p><ul><li>定义任意非叶子结点最多只有M个儿子，且M&gt;2。</li><li>根结点的儿子数为[2, M]。</li><li>除根结点以外的非叶子结点的儿子数为[M/2, M]。</li><li>每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）。</li><li>非叶子结点的关键字个数=指向儿子的指针个数-1。</li><li>非叶子结点的关键字：K[1], K[2], …, K[M-1]，且K[i] &lt;= K[i+1]。</li><li>非叶子结点的指针：P[1], P[2], …,P[M]（其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树）。</li><li>所有叶子结点位于同一层。</li></ul></blockquote><p>下图是一个M=4阶的B树。</p><p><img src="https://gitee.com/yuanlu_k/BlogImages/raw/master/MySQL%E7%B4%A2%E5%BC%95/B%E6%A0%91.jpg" srcset="/img/loading.gif" alt="B树"><br>B树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的是叶子结点。</p><blockquote><p><strong><em>查找文件29的过程：</em></strong></p><ul><li>根据根结点指针找到文件目录的根磁盘块1，将其中的信息导入内存。（磁盘IO操作1次）</li><li>此时内存中有两个文件名17，35和三个存储其他磁盘页面地址的数据。根据算法我们发现17&lt;29&lt;35，因此我们找到指针p2。</li><li>根据p2指针，我们定位到磁盘块3，并将其中的信息导入内存。（磁盘IO操作2次）</li><li>此时内存中有两个文件名26，30和三个存储其他磁盘页面地址的数据。根据算法我们发现26&lt;29&lt;30，因此我们找到指针p2。</li><li>根据p2指针，我们定位到磁盘块8，并将其中的信息导入内存。（磁盘IO操作3次）</li><li>此时内存中有两个文件名28，29。根据算法我们查找到文件29，并定位了该文件内存的磁盘地址。</li></ul></blockquote><blockquote><p><strong><em>B树的特性：</em></strong></p><ul><li>关键字分布在整颗树的所有节点。</li><li>任何一个关键字出现且只出现在一个结点中。</li><li>搜索有可能在非叶子结点结束。</li><li>其搜索性能等价于在关键字全集内做一次二分查找。</li></ul></blockquote><h3 id="1-2-B-树"><a href="#1-2-B-树" class="headerlink" title="1.2. B+树"></a>1.2. B+树</h3><p>下图是一个M=3阶的B+树。</p><p><img src="https://gitee.com/yuanlu_k/BlogImages/raw/master/MySQL%E7%B4%A2%E5%BC%95/B+%E6%A0%91.jpg" srcset="/img/loading.gif" alt="B+树"></p><p>B+树是B树的一种变形树，总结起来，数据库索引的B+树与B树的差异在于：</p><ul><li>非叶子结点的子树指针与关键字个数相同。</li><li>非叶子结点的子树指针P[i]，指向关键字值属于[K[i],K[i+1])的子树（注意，区间是前闭后开）。</li><li>为所有叶子结点增加一个链指针。</li><li>所有关键字都在叶子结点出现。</li></ul><blockquote><p><strong><em>B+树的特性：</em></strong></p><ul><li>所有关键字都出现在叶子结点的链表中，且链表中的关键字是有序的。</li><li>搜索只在叶子结点命中。</li><li>非叶子结点相当于是叶子结点的索引，叶子结点是存储关键字数据的数据层。</li></ul></blockquote><h3 id="1-3-B-树做索引的原因"><a href="#1-3-B-树做索引的原因" class="headerlink" title="1.3. B-/+树做索引的原因"></a>1.3. B-/+树做索引的原因</h3><p>解释这个问题之前，需要了解一些基础知识。</p><p><strong><em>局部性原理与磁盘预读</em></strong><br>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：</p><blockquote><p>当一个数据被用到时，其附近的数据也通常会马上被使用——程序运行期间所需要的数据通常比较集中。</p></blockquote><p>由于磁盘<strong><em>顺序读取</em></strong>的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p><p>预读的长度一般为页的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p><p><strong><em>B-/+树做索引的原因分析</em></strong><br>一般来说，磁盘I/O次数可以用于评价索引结构的优劣。在B-Tree中查找，可知检索一次最多需要访问h个节点（上文举例查找文件29的过程）。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。</p><p>为了达到这个目的，在实际实现中，B树还使用如下技巧：</p><ul><li>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个节点只需一次I/O。</li><li>B树中一次检索最多需要h-1次I/O（根节点常驻内存）。一般实际应用中，出度d（树的分叉数）是非常大的数字，通常超过100；h非常小，通常不超过3。</li></ul><p>综上所述，用B树作为索引结构效率是非常高的。</p><p><strong><em>红黑树或者平衡二叉树的其他树结构</em></strong></p><ul><li>h明显要深的多，执行效率低。</li><li>逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，</li><li>每个节点存储的数据量太小了，对磁盘空间造成浪费，带来频繁的IO操作。</li></ul><p>所以其他树结构的效率明显比B树差很多。</p><blockquote><p><strong><em>相对B树，B+树做索引的优势</em></strong></p><ul><li>B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。</li><li>B+树的查询效率更加稳定：由于所有数据都存于叶子节点。所有关键字查询的路径长度相同，每一个数据的查询效率相当。</li><li>B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。</li></ul></blockquote><p>笔者认为第三条原因才是MySQL使用B+树而不是B树做索引的主要原因，毕竟MongoDB的索引是B树，所以两种数据结构并没有绝对的好坏，要看实际的业务需求。</p><p>文章源于：<a href="https://zhuanlan.zhihu.com/p/88866208" target="_blank" rel="noopener">一文彻底搞懂MySQL索引</a></p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>B-/+树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式 -- 代理模式</title>
    <link href="/2020/08/15/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/08/15/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>设计模式之代理模式，代理模式又分为静态代理和动态代理。</p><a id="more"></a><h2 id="1-代理模式UML示意图"><a href="#1-代理模式UML示意图" class="headerlink" title="1. 代理模式UML示意图"></a>1. 代理模式UML示意图</h2><p><img src="https://gitee.com/yuanlu_k/BlogImages/raw/master/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/proxyUML.jpg" srcset="/img/loading.gif" alt="代理模式"></p><blockquote><p>需要注意的有下面几点：</p><ol><li>用户(Client)只关心接口功能，而不在乎谁提供了功能。上图中接口是 Subject。</li><li>接口真正实现者是上图的 RealSubject，但是它不与用户直接接触，而是通过代理。</li><li>代理就是上图中的 Proxy，由于它实现了 Subject 接口，所以它能够直接与用户接触。</li><li>用户调用 Proxy 的时候，Proxy 内部调用了 RealSubject。所以，Proxy 是中介者，它可以增强 RealSubject 操作。</li></ol></blockquote><h2 id="2-静态代理"><a href="#2-静态代理" class="headerlink" title="2. 静态代理"></a>2. 静态代理</h2><p>静态代理在使用时,需要定义接口或者父类，<strong>被代理对象与代理对象一起实现相同的接口或者是继承相同父类</strong>。在<u>代理对象</u>中对<u>被代理对象</u>进行增强。</p><p>假设这样一个场景：有一个蛋糕店，它们卖的蛋糕都是用蛋糕机做的，而且不同种类的蛋糕由不同的蛋糕机来做，这样就有：水果蛋糕机、巧克力蛋糕机等。它们卖的面包片也是用面包机做的，同样不同种类的面包片也是由不同的面包机来做，这样就有：葡萄干面包机、红豆面包机等。这个场景用 Java 语言描述就是下面这样：</p><pre><code class="hljs java"><span class="hljs-comment">//做蛋糕的机器</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CakeMachine</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">makeCake</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//专门做水果蛋糕的机器</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FruitCakeMachine</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CakeMachine</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeCake</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"Making a fruit cake..."</span>);    &#125;&#125;<span class="hljs-comment">//专门做巧克力蛋糕的机器</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChocolateCakeMachine</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CakeMachine</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeCake</span><span class="hljs-params">()</span> </span>&#123;        System.out.printf(<span class="hljs-string">"making a Chocolate Cake..."</span>);    &#125;&#125;<span class="hljs-comment">//做面包的机器</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BreadMachine</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">makeBread</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//专门做红豆面包的机器</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedBeanBreadMachine</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BreadMachine</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeBread</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"making red bean bread...."</span>);    &#125;&#125;<span class="hljs-comment">//专门做葡萄干面包的机器</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CurrantBreadMachine</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BreadMachine</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeBread</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"making currant bread..."</span>);    &#125;&#125;<span class="hljs-comment">//蛋糕店</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CakeShop</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">new</span> FruitCakeMachine().makeCake();        <span class="hljs-keyword">new</span> ChocolateCakeMachine().makeCake();        <span class="hljs-keyword">new</span> RedBeanBreadMachine().makeBread();        <span class="hljs-keyword">new</span> CurrantBreadMachine().makeBread();    &#125;&#125;</code></pre><p>上面的代码抽象出了一个 CakeMachine 接口和 BreadMachine 接口，有各种蛋糕机（FruitCakeMachine、ChocolateCakeMachine 等）实现了 CakeMachine 接口，有各种面包机（RedBeanBreadMachine、CurrantBreadMachine 等）实现了 BreadMachine 接口，最后蛋糕店（CakeShop）直接利用这些蛋糕机做蛋糕。</p><p>这样的一个例子真实地描述了实际生活中的场景。但生活中的场景往往是复杂多变的，假设这个时候来了一个顾客，他想要一个水果蛋糕，但他特别喜欢杏仁，希望在水果蛋糕上加上一层杏仁。这时候我们应该怎么做呢？</p><p>因为我们的蛋糕机只能做水果蛋糕（程序设定好了），没办法做杏仁水果蛋糕。最简单的办法是直接修改水果蛋糕机的程序，做一台能做杏仁水果蛋糕的蛋糕机。这种方式对应的代码修改也很简单，直接在原来的代码上进行修改，生成一台专门做杏仁水果蛋糕的机器就好了，修改后的 FruitCakeMachien 类应该是这样子：</p><pre><code class="hljs java"><span class="hljs-comment">//专门做水果蛋糕的机器，并且加上一层杏仁</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FruitCakeMachine</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CakeMachine</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeCake</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"making a Fruit Cake..."</span>);        System.out.println(<span class="hljs-string">"adding apricot..."</span>);    &#125;&#125;</code></pre><p>虽然上面这种方式实现了我们的业务需求。但是仔细想一想，在现实生活中如果我们遇到这样的一个需求，我们不可能因为一个顾客的特殊需求就去修改一台蛋糕机的硬件程序，这样成本太高！而且从代码实现角度上来说，<strong>这种方式从代码上不是很优雅，修改了原来的代码</strong>。根据代码圈中<strong>「对修改封闭、对扩展开放」</strong>的思想，我们在尝试满足新的业务需求的时候应该尽量少修改原来的代码，而是在原来的代码上进行拓展。</p><p>那我们究竟应该怎么做更加合适一些呢？我们肯定是直接用水果蛋糕机做一个蛋糕，然后再人工撒上一层杏仁啦。我们需要做的，其实就是设计一个杏仁代理类（ApricotCakeProxy），这个代理类就完成撒杏仁这个动作，之后让蛋糕店直接调用即可代理类去实现即可。</p><pre><code class="hljs java"><span class="hljs-comment">//杏仁蛋糕代理</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApricotCakeProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CakeMachine</span></span>&#123;    <span class="hljs-keyword">private</span> CakeMachine cakeMachine;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ApricotCakeProxy</span><span class="hljs-params">(CakeMachine cakeMachine)</span> </span>&#123;        <span class="hljs-keyword">this</span>.cakeMachine = cakeMachine;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeCake</span><span class="hljs-params">()</span> </span>&#123;        cakeMachine.makeCake();        System.out.println(<span class="hljs-string">"adding apricot..."</span>);    &#125;&#125;<span class="hljs-comment">//蛋糕店</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CakeShop</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//可以给各种各样的蛋糕加上杏仁</span>        FruitCakeMachine fruitCakeMachine = <span class="hljs-keyword">new</span> FruitCakeMachine();        ApricotCakeProxy apricotProxy = <span class="hljs-keyword">new</span> ApricotCakeProxy(fruitCakeMachine);        apricotProxy.makeCake();        apricotProxy = <span class="hljs-keyword">new</span> ApricotCakeProxy(<span class="hljs-keyword">new</span> ChocolateCakeMachine());        apricotProxy.makeCake();    &#125;&#125;</code></pre><p>这其实就对应了即使模式中的<strong>代理模式</strong>，虽然调用的是 ApricotCakeProxy 类的方法，但实际上真正做蛋糕的是 FruitCakeMachine 类。ApricotCakeProxy 类只是在 FruitCakeMachine 做出蛋糕后，撒上一层杏仁而已。而且通过代理，我们不仅可以给水果蛋糕撒上一层杏仁，还可以给巧克力蛋糕、五仁蛋糕等撒上一层杏仁。只要它是蛋糕（实现了 CakeMachine 接口），那么我们就可以给这个蛋糕撒上杏仁。</p><p>通过代理实现这样的业务场景，这样我们就不需要在原来的类上进行修改，从而使得代码更加优雅，拓展性更强。如果下次客人喜欢葡萄干水果蛋糕了了，那可以再写一个 CurrantCakeProxy 类来撒上一层葡萄干，原来的代码也不会被修改。上面说的这种业务场景就是代理模式的实际应用，准确地说这种是<strong>静态代理。</strong></p><p>小结：<strong>静态代理模式可以在不修改被代理对象的基础上，通过扩展代理类，进行一些功能的附加与增强。值得注意的是，代理类和被代理类应该共同实现一个接口，或者是共同继承某个类。</strong></p><h2 id="3-动态代理"><a href="#3-动态代理" class="headerlink" title="3. 动态代理"></a>3. 动态代理</h2><p>业务场景的复杂度往往千变万化，如果这个特别喜欢杏仁的客人，他也想在面包上撒一层杏仁，那我们怎么办？我们能够使用之前写的 ApricotCakeProxy 代理类么？不行，因为 ApricotCakeProxy 里规定了只能为蛋糕（实现了 CakeMachine 接口）的实体做代理。这种情况下，我们只能再写一个可以为所有面包加杏仁的代理类：ApricotBreadProxy。</p><pre><code class="hljs java"><span class="hljs-comment">//杏仁面包代理</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApricotBreadProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BreadMachine</span></span>&#123;    <span class="hljs-keyword">private</span> BreadMachine breadMachine;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ApricotBreadProxy</span><span class="hljs-params">(BreadMachine breadMachine)</span> </span>&#123;        <span class="hljs-keyword">this</span>.breadMachine = breadMachine;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeBread</span><span class="hljs-params">()</span> </span>&#123;        breadMachine.makeBread();        System.out.println(<span class="hljs-string">"adding apricot..."</span>);    &#125;&#125;<span class="hljs-comment">//蛋糕店</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CakeShop</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;          <span class="hljs-comment">//可以给各种各样的面包加上杏仁</span>        RedBeanBreadMachine redBeanBreadMachine = <span class="hljs-keyword">new</span> RedBeanBreadMachine();        ApricotBreadProxy apricotBreadProxy = <span class="hljs-keyword">new</span> ApricotBreadProxy(redBeanBreadMachine);        apricotBreadProxy.makeBread();        CurrantBreadMachine currantBreadMachine = <span class="hljs-keyword">new</span> CurrantBreadMachine();        apricotBreadProxy = <span class="hljs-keyword">new</span> ApricotBreadProxy(currantBreadMachine);        apricotBreadProxy.makeBread();    &#125;&#125;</code></pre><p>最终输出结果：</p><pre><code class="hljs java">making red bean bread....adding apricot...making currant bread...adding apricot...</code></pre><p>我们可以看到我们也成功地做出了客人想要的杏仁红豆面包、杏仁葡萄干面包。</p><p>对于客人来说，他肯定希望我们所有的产品都有一层杏仁，这样客人最喜欢了。为了满足客人的需求，那如果我们的产品有 100 种（饼干、酸奶等），我们是不是得写 100 个代理类呢？有没有一种方式可以让我们只写一次实现（撒杏仁的实现），但是任何类型的产品（蛋糕、面包、饼干、酸奶等）都可以使用呢？其实在 Java 中早已经有了针对这种情况而设计的一个接口，专门用来解决类似的问题，它就是<strong>动态代理 —— InvocationHandler。</strong></p><p><strong>动态代理与静态代理的区别是静态代理只能针对特定一种产品（蛋糕、面包、饼干、酸奶）做某种代理动作（撒杏仁），而动态代理则可以对所有类型产品（蛋糕、面包、饼干、酸奶等）做某种代理动作（撒杏仁）。</strong></p><p>接下来我们针对这个业务场景做一个代码的抽象实现。首先我们分析一下可以知道这种场景的共同点是希望在所有产品上都做「撒一层杏仁」的动作，所以我们就做一个杏仁动态代理（ApricotHandler）。</p><pre><code class="hljs java"><span class="hljs-comment">//杏仁动态代理</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApricotHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span></span>&#123;    <span class="hljs-keyword">private</span> Object object;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ApricotHandler</span><span class="hljs-params">(Object object)</span> </span>&#123;        <span class="hljs-keyword">this</span>.object = object;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        Object result = method.invoke(object, args);    <span class="hljs-comment">//调用真正的蛋糕机做蛋糕</span>        System.out.println(<span class="hljs-string">"adding apricot..."</span>);        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre><p>撒杏仁的代理写完之后，我们直接让蛋糕店开工：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CakeShop</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//动态代理(可以同时给蛋糕、面包等加杏仁)</span>        <span class="hljs-comment">//给蛋糕加上杏仁</span>        FruitCakeMachine fruitCakeMachine = <span class="hljs-keyword">new</span> FruitCakeMachine();        ApricotHandler apricotHandler = <span class="hljs-keyword">new</span> ApricotHandler(fruitCakeMachine);        CakeMachine cakeMachine = (CakeMachine) Proxy.newProxyInstance(fruitCakeMachine.getClass().getClassLoader(),                fruitCakeMachine.getClass().getInterfaces(),                apricotHandler);        cakeMachine.makeCake();        <span class="hljs-comment">//给面包加上杏仁</span>        RedBeanBreadMachine redBeanBreadMachine = <span class="hljs-keyword">new</span> RedBeanBreadMachine();        apricotHandler = <span class="hljs-keyword">new</span> ApricotHandler(redBeanBreadMachine);        BreadMachine breadMachine = (BreadMachine) Proxy.newProxyInstance(redBeanBreadMachine.getClass().getClassLoader(),                redBeanBreadMachine.getClass().getInterfaces(),                apricotHandler);        breadMachine.makeBread();    &#125;&#125;</code></pre><p>输出结果为：</p><pre><code class="hljs java">making a fruit cake...adding apricot...making red bean bread....adding apricot...</code></pre><p>从输出结果可以知道，这与我们想要的结果是一致的。与静态代理相比，动态代理具有更加的普适性，能减少更多重复的代码。试想这个场景如果使用静态代理的话，我们需要对每一种类型的蛋糕机都写一个代理类（ApricotCakeProxy、ApricotBreadProxy、ApricotCookieProxy等）。但是如果使用动态代理的话，我们只需要写一个通用的撒杏仁代理类（ApricotHandler）就可以直接完成所有操作了。直接省去了写 ApricotCakeProxy、ApricotBreadProxy、ApricotCookieProxy 的功夫，极大地提高了效率。</p><p>看到这里，大家应该清楚为什么有了静态代理之后，还需要有动态代理了吧。<strong>静态代理只能针对某一接口（面包 或 蛋糕）进行操作，如果要对所有接口都（所有产品）都能做一样操作，那就必须要动态代理出马了。</strong></p><h2 id="4-如何使用动态代理？"><a href="#4-如何使用动态代理？" class="headerlink" title="4. 如何使用动态代理？"></a>4. 如何使用动态代理？</h2><p>参照上面的例子，我们可以知道要实现动态代理需要做两方面的工作。</p><ul><li>必须新建一个类，并且这个类必须实现 <strong>InvocationHandler</strong> 接口。</li></ul><pre><code class="hljs java"><span class="hljs-comment">//杏仁动态代理</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApricotHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span></span>&#123;    <span class="hljs-keyword">private</span> Object object;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ApricotHandler</span><span class="hljs-params">(Object object)</span> </span>&#123;        <span class="hljs-keyword">this</span>.object = object;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        Object result = method.invoke(object, args);    <span class="hljs-comment">//调用真正的蛋糕机做蛋糕</span>        System.out.println(<span class="hljs-string">"adding apricot..."</span>);        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre><ul><li>在调用的时候使用 Proxy.newProxyInstance() 方法生成代理类。</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CakeShop</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//给蛋糕加上杏仁</span>        FruitCakeMachine fruitCakeMachine = <span class="hljs-keyword">new</span> FruitCakeMachine();        ApricotHandler apricotHandler = <span class="hljs-keyword">new</span> ApricotHandler(fruitCakeMachine);        CakeMachine cakeMachine = (CakeMachine) Proxy.newProxyInstance(fruitCakeMachine.getClass().getClassLoader(),                fruitCakeMachine.getClass().getInterfaces(),                apricotHandler);        cakeMachine.makeCake();&#125;</code></pre><ul><li>最后直接使用生成的代理类调用相关的方法即可。</li></ul><p>Tips:</p><pre><code class="hljs java"><span class="hljs-comment">/** </span><span class="hljs-comment">  * Proxy</span><span class="hljs-comment">  * 动态代理的语法</span><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> loader 自然是类加载器</span><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> interfaces 代码要用来代理的接口</span><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> h 一个InvocationHandler对象</span><span class="hljs-comment">  * <span class="hljs-doctag">@return</span> 代理对象</span><span class="hljs-comment">  */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">newProxyInstance</span><span class="hljs-params">(ClassLoader loader,</span></span><span class="hljs-function"><span class="hljs-params">                                          Class&lt;?&gt;[] interfaces,</span></span><span class="hljs-function"><span class="hljs-params">                                          InvocationHandler h)</span></span></code></pre><pre><code class="hljs java"><span class="hljs-comment">//InvocationHandler</span><span class="hljs-comment">//InvocationHandler 是一个接口，官方文档解释说，每个代理的实例都有一个与之关联的 InvocationHandler 实现类，如果代理的方法被调用，那么代理便会通知和转发给内部的 InvocationHandler 实现类，由它决定处理。</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment">  * 内部只是一个 invoke() 方法，正是这个方法决定了怎么样处理代理传递过来的方法调用。</span><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> proxy 代理对象</span><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> method 代理对象调用的方法</span><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> args 调用方法中的参数</span><span class="hljs-comment">  * <span class="hljs-doctag">@return</span> </span><span class="hljs-comment">  */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable</span>;&#125;</code></pre><h2 id="5-动态代理的几种实现方式"><a href="#5-动态代理的几种实现方式" class="headerlink" title="5. 动态代理的几种实现方式"></a>5. 动态代理的几种实现方式</h2><p>动态代理其实指的是一种设计模式概念，指的是通过代理来做一些通用的事情，常见的应用有权限系统、日志系统等，都用到了动态代理。</p><p>而 <strong>Java 动态代理只是动态代理的一种实现方式而已</strong>，动态代理还有另外一种实现方式，即 <strong>CGLib</strong>（Code Generation Library）。</p><p>Java 动态代理只能<strong>针对实现了接口的类进行拓展</strong>，所以细心的朋友会发现我们的代码里有一个叫 MachineCake 的接口。而 CGLib 则没有这个限制，因为 CGLib 是使用继承原有类的方式来实现代理的。</p><p>我们还是举个例子来说明 <strong>CGLib 是如何实现动态代理的</strong>吧。还是前面的例子：我们要做杏仁水果蛋糕、巧克力水果蛋糕、五仁巧克力蛋糕，这时候用代码描述是这样的。</p><p>首先我们需要写一个杏仁拦截器类，这个拦截器可以给做好的蛋糕加上杏仁。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApricotInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        methodProxy.invokeSuper(o, objects);        System.out.println(<span class="hljs-string">"adding apricot..."</span>);        <span class="hljs-keyword">return</span> o;    &#125;&#125;</code></pre><p>接着直接让蛋糕店使用 CGLib 提供的工具类做杏仁水果蛋糕：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CakeShop</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;         <span class="hljs-comment">//CGLib动态代理(可以同时给蛋糕、面包等加杏仁)</span>        Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();        enhancer.setSuperclass(FruitCakeMachine<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        enhancer.setCallback(<span class="hljs-keyword">new</span> ApricotInterceptor());        FruitCakeMachine fruitCakeMachine = (FruitCakeMachine) enhancer.create();        fruitCakeMachine.makeCake();    &#125;&#125;</code></pre><p>上面的 enhancer.setSuperClass() 设置需要增强的类，而 enhancer.setCallback() 则设置需要回调的拦截器，即实现了 MethodInterceptor 接口的类。最后最后使用 enhancer.create() 生成了对应的增强类，最后输出结果为：</p><pre><code class="hljs java">making a fruit cake...adding apricot...</code></pre><p>和我们预期的一样。如果要做一个杏仁面包片，那么直接让蛋糕店利用ApricotHandler 再做一个就可以了，它们的区别只是传入的增强类不同。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CakeShop</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;           <span class="hljs-comment">//做一个杏仁面包片</span>          Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();        enhancer.setSuperclass(RedBeanBreadMachine<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        enhancer.setCallback(<span class="hljs-keyword">new</span> ApricotInterceptor());        RedBeanBreadMachine chocolateCakeMachine = (RedBeanBreadMachine) enhancer.create();        chocolateCakeMachine.makeBread();    &#125;&#125;</code></pre><p>可以看到，这里传入的增强类是 RedBeanBreadMachine，而不是之前的 FruitCakeMachine。</p><p>对比 Java 动态代理和 CGLib 动态代理两种实现方式，你会发现 <strong>Java 动态代理适合于那些有接口抽象的类代理，而 CGLib 则适合那些没有接口抽象的类代理。</strong></p><h3 id="5-1-Java动态代理的原理"><a href="#5-1-Java动态代理的原理" class="headerlink" title="5.1. Java动态代理的原理"></a>5.1. Java动态代理的原理</h3><p>从上面的例子我们可以知道，Java 动态代理的入口是从 Proxy.newInstance() 方法中开始的，通过这个方法，Java 替我们生成了一个继承了指定接口（CakeMachine）的代理类（ApricotHandler）实例。Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) 方法简单来说执行了以下操作：</p><blockquote><p> 1、生成一个实现了参数 interfaces 里所有接口且继承了 Proxy 的代理类的字节码，然后用参数里的 classLoader 加载这个代理类。<br>2、使用代理类父类的构造函数 Proxy(InvocationHandler h) 来创造一个代理类的实例，将我们自定义的 InvocationHandler 的子类传入。<br>3、返回这个代理类实例，因为我们构造的代理类实现了 interfaces（也就是我们程序中传入的 fruitCakeMachine.getClass().getInterfaces() 里的所有接口，因此返回的代理类可以强转成 MachineCake 类型来调用接口中定义的方法。</p></blockquote><h3 id="5-2-CGLib动态代理的原理"><a href="#5-2-CGLib动态代理的原理" class="headerlink" title="5.2 CGLib动态代理的原理"></a>5.2 CGLib动态代理的原理</h3><p>因为 JVM 并不允许在运行时修改原有类，所以所有的动态性都是通过新建类来实现的，上面说到的 Java 动态代理也不例外。所以对于 CGLib 动态代理的原理，其实也是通过动态生成代理类，最后由代理类来完成操作实现的。</p><p>对于 CGLib 动态代理的实现，我并没有深入到源码中，而是通过查阅资料了解了其大概的实现原理。</p><ul><li>首先，我们在使用的时候通过 enhancer.setSuperclass(FruitCakeMachine.class) 传入了需要增加的类，CGLib 便会生成一个继承了该类的代理类。</li><li>接着，我们通过 enhancer.setCallback(new ApricotInterceptor()) 传入了代理类对象，CGLib 通过组装两个类的结构实现一个静态代理，从而达到具体的目的。</li></ul><p>而在 CGLib 生成新类的过程中，其使用的是一个名为 ASM 的东西，它对 Java 的 class 文件进行操作、生成新的 class 文件。如果你对 CGLib 的原理感兴趣，不妨看看这篇文章：<a href="https://www.zhihu.com/question/从兄弟到父子：动态代理在民间是怎么玩的？" target="_blank" rel="noopener">从兄弟到父子：动态代理在民间是怎么玩的？</a></p><h2 id="6-动态代理的应用"><a href="#6-动态代理的应用" class="headerlink" title="6. 动态代理的应用"></a>6. 动态代理的应用</h2><p>动态代理在代码界可是有非常重要的意义，我们开发用到的许多框架都使用到了这个概念。我所知道的就有：Spring AOP、Hibernate、Struts 使用到了动态代理。</p><ul><li><strong>Spring AOP。</strong>Spring 最重要的一个特性是 AOP（Aspect Oriented Programming 面向切面编程），利用 Spring AOP 可以快速地实现权限校验、安全校验等公用操作。而 Spring AOP 的原理则是通过动态代理实现的，默认情况下 Spring AOP 会采用 Java 动态代理实现，而当该类没有对应接口时才会使用 CGLib 动态代理实现。</li><li><strong>Hibernate。</strong>Hibernate 是一个常用的 ORM 层框架，在获取数据时常用的操作有：get() 和 load() 方法，它们的区别是：get() 方法会直接获取数据，而 load() 方法则会延迟加载，等到用户真的去取数据的时候才利用代理类去读数据库。</li><li><strong>Struts。</strong>Struts 现在虽然因为其太多 bug 已经被抛弃，但是曾经用过 Struts 的人都知道 Struts 中的拦截器。拦截器有非常强的 AOP 特性，仔细了解之后你会发现 Struts 拦截器其实也是用动态代理实现的。</li></ul><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>我们通过蛋糕店的不同业务场景介绍了静态代理和动态代理的应用，接着重点介绍了动态代理两种实现方式（Java 动态代理、CGLib 动态代理）的使用方法及其实现原理，其中还针对 Java 动态代理的源码进行了简单的分析。最后，我们介绍了动态代理在实际上编程中的应用（Spring AOP、Hibernate、Struts）。</p><p>希望这篇文章帮助大家更好地理解动态代理。</p><p>参考：<a href><a href="https://www.cnblogs.com/chanshuyi/p/deep_insight_java_proxy_pattern.html">Java动态代理：一个面包店的动态代理帝国</a></a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot 、Mybatis 与 websocket 之间的一些问题</title>
    <link href="/2020/08/14/WebSocket%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98/"/>
    <url>/2020/08/14/WebSocket%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>SpringBoot 、Mybatis 与 websocket 之间的一些问题，欢迎交流，指证错误。</p><a id="more"></a><p>最近在做一个小项目，用到了SpringBoot 和 websocket，先大概讲一下所遇到的问题。</p><p>问题：</p><blockquote><p>前端JS通过websocket和和服务器中的WebSocketServlet 连接，在WebSocketServlet中注入HeatMapService，这时候出现第一个问题，<font color="red">发现注入的HeatMapService为null，也就是说这个时候Spring容器无法将HeatMapService注入</font>；当时没太在意，想着既然Spring无法注入，那就自己实例化 HeatMapService 就好了，然后就傻乎乎的自己实例化了HeatMapService，到这没啥大问题，至少代码跑起来了。下午准备把数据存到数据库时，出现了第二个问题，<font color="red">在HeatMapServiceImpl中想要注入HeatMapMapper时，发现此时注入的HeatMapMapper居然也为null</font>，自己的第一反应是Mybatis和SpringBoot整合时可能出问题了，检查MainApplication.java上有添加@MapperScanner，对应路径也没有写错，那这是为什么无法注入Mapper呢？</p></blockquote><p>服务端websocket中的<font color="red">部分错误代码</font>：</p><pre><code class="hljs java"><span class="hljs-meta">@ServerEndpoint</span>(value = <span class="hljs-string">"/websocket"</span>)<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSocketServlet</span> </span>&#123;        <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> HeatMapService heatMapService;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;    <span class="hljs-comment">//用来存放每个客户端对应的webSocketSet对象。</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> CopyOnWriteArraySet&lt;WebSocketServlet&gt; webSocketSet = <span class="hljs-keyword">new</span> CopyOnWriteArraySet&lt;WebSocketServlet&gt;();    <span class="hljs-keyword">private</span>  Session session=<span class="hljs-keyword">null</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@ClassName</span>: onOpen</span><span class="hljs-comment">     * <span class="hljs-doctag">@Description</span>: 开启连接的操作</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@OnOpen</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onOpen</span><span class="hljs-params">(Session session)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;       <span class="hljs-comment">//TODO</span>    &#125;&#125;</code></pre><p>先解决第二个问题：</p><p>经过几个小时zz般的排查，依旧没有想清SpringBoot 和 Mybatis整合到底哪出错了，于是准备把整个流程重新捋一遍，当走到WebSocketServlet 时，才发现是自己上午实例化的HeatMapService的问题。<font color="red">由于是自己的手动实例化的，因此实例化的heatMapService对象肯定是不在Spring容器中的，根据Spring的“依赖注入”，自然也无法将HeatMapMapper注入到Spring容器中</font>。知道问题所在，那就把HeatMapService通过Spring的方式注入进容器即可，问题二解决。</p><p>问题二解决了，自然问题一又回来了，为什么WebSocketServlet 中无法注入HeatMapService呢 ？<font color="red">原来WebSocket是多例的，而Spring管理的对象默认是单例的，即Spring默认只实例化一次HeatMapService，而WebSocketServlet 每新添加一个连接就会新增一个socket对象，自然无法将每一个socket对象中的HeatMapService进行实例化注入</font>。解决的办法就是将HeatMapService由成员变量，变成类变量即可，让所有的socket对象共享同一个HeatMapService。</p><p>问题解决后的WebSocketServlet 代码：</p><pre><code class="hljs java"><span class="hljs-meta">@ServerEndpoint</span>(value = <span class="hljs-string">"/websocket"</span>)<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSocketServlet</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> HeatMapService heatMapService;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHeatMapService</span><span class="hljs-params">(HeatMapService heatMapService)</span></span>&#123;        WebSocketServlet.heatMapService = heatMapService;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;    <span class="hljs-comment">//用来存放每个客户端对应的webSocketSet对象。</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> CopyOnWriteArraySet&lt;WebSocketServlet&gt; webSocketSet = <span class="hljs-keyword">new</span> CopyOnWriteArraySet&lt;WebSocketServlet&gt;();    <span class="hljs-keyword">private</span>  Session session=<span class="hljs-keyword">null</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@ClassName</span>: onOpen</span><span class="hljs-comment">     * <span class="hljs-doctag">@Description</span>: 开启连接的操作</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@OnOpen</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onOpen</span><span class="hljs-params">(Session session)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;      <span class="hljs-comment">//TODO</span>    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@ClassName</span>: onClose</span><span class="hljs-comment">     * <span class="hljs-doctag">@Description</span>: 连接关闭的操作</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@OnClose</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClose</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"connection is closed..."</span>);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@ClassName</span>: onMessage</span><span class="hljs-comment">     * <span class="hljs-doctag">@Description</span>: 从前端接收消息</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@OnMessage</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(String message)</span> </span>&#123;        <span class="hljs-comment">//TODO</span>    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@ClassName</span>: OnError</span><span class="hljs-comment">     * <span class="hljs-doctag">@Description</span>: 出错的操作</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@OnError</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable error)</span></span>&#123;        System.out.println(error);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 将消息发送给前端</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(SensorVO sensor)</span></span>&#123;        <span class="hljs-comment">//TODO</span>    &#125;&#125;</code></pre><p>参考 ：<a href="https://blog.csdn.net/m0_37202351/article/details/86255132" target="_blank" rel="noopener">spring springboot websocket 不能注入( @Autowired ) service bean 报 null 错误</a></p><p>还是自己code太少了，项目经验太少，这样的错误，希望自己以后不会再犯~</p>]]></content>
    
    
    <categories>
      
      <category>Problems</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Problems</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
