<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java GC 知识小结</title>
    <link href="/2020/07/24/Java-GC%E5%B0%8F%E7%BB%93/"/>
    <url>/2020/07/24/Java-GC%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>Java GC相关知识小结，欢迎交流，指证错误。</p><a id="more"></a><h1 id="1-什么是垃圾？怎么寻找垃圾？"><a href="#1-什么是垃圾？怎么寻找垃圾？" class="headerlink" title="1. 什么是垃圾？怎么寻找垃圾？"></a>1. 什么是垃圾？怎么寻找垃圾？</h1><h2 id="1-1-什么是垃圾？"><a href="#1-1-什么是垃圾？" class="headerlink" title="1.1. 什么是垃圾？"></a>1.1. 什么是垃圾？</h2><blockquote><p><em>不再被引用的对象称为垃圾。</em></p></blockquote><h2 id="1-2-垃圾寻找方法（垃圾标记方法）："><a href="#1-2-垃圾寻找方法（垃圾标记方法）：" class="headerlink" title="1.2 . 垃圾寻找方法（垃圾标记方法）："></a>1.2 . 垃圾寻找方法（垃圾标记方法）：</h2><h3 id="1-2-1-引用计数算法（Reference-Counting）："><a href="#1-2-1-引用计数算法（Reference-Counting）：" class="headerlink" title="1.2.1.  引用计数算法（Reference Counting）："></a>1.2.1.  引用计数算法（Reference Counting）：</h3><p>介绍：给对象添加一个引用计数器，每当一个地方引用它时，计数器加1；当引用失效时，计数器减1；计数器为0的即可被回收。</p><blockquote><p>优点：实现简单，判断效率高。<br>缺点：存在循环引用（objA.instance = objB; objB.instance = objA）的问题，所以Java语言并没有选用引用计数法管理内存。</p></blockquote><h3 id="1-2-2-根搜索算法（GC-Root-Searching）"><a href="#1-2-2-根搜索算法（GC-Root-Searching）" class="headerlink" title="1.2.2. 根搜索算法（GC Root Searching）"></a>1.2.2. 根搜索算法（GC Root Searching）</h3><p>Java和C#都是使用根搜索算法来判断对象是否存活。通过一系列的名为“GC Root”的对象作为起始点，从这些节点开始向下搜索，搜索所有走过的路径称为引用链（Reference Chain）,当一个对象到GC Root没有任何引用链相连时（用图论来说就是GC Root到这个对象不可达时），证明该对象是可以被回收的。</p><blockquote><p>不存在循环引用问题。</p></blockquote><blockquote><p>在Java中哪些对象可以成为GC Root?</p><ul><li>虚拟机栈（栈帧中的本地变量表）中的引用对象</li><li>方法区中的类静态属性引用的对象</li><li>方法区中的常量引用对象</li><li>本地方法栈中JNI（即Native方法）的引用对象</li></ul></blockquote><h1 id="2-常见的垃圾收集算法有哪些？"><a href="#2-常见的垃圾收集算法有哪些？" class="headerlink" title="2. 常见的垃圾收集算法有哪些？"></a>2. 常见的垃圾收集算法有哪些？</h1><h2 id="2-1-标记清除-Mark-sweep"><a href="#2-1-标记清除-Mark-sweep" class="headerlink" title="2.1 标记清除(Mark-sweep)"></a>2.1 标记清除(Mark-sweep)</h2><p>这是垃圾收集算法中最基础的，根据名字就可以知道，它的思想就是标记那些要被回收的对象，然后统一回收。这种方法很简单，但是会有两个主要问题：</p><blockquote><ul><li>效率不高，标记和清除的效率都很低；</li><li>会产生大量不连续的内存碎片，导致以后程序在分配交大的对象时，由于没有充足的连续内存而提前触发一次GC动作。</li></ul></blockquote><h2 id="2-2-复制算法-Copying"><a href="#2-2-复制算法-Copying" class="headerlink" title="2.2. 复制算法(Copying)"></a>2.2. 复制算法(Copying)</h2><p>为了解决效率问题，复制算法将可用内存按容量划分相等的两部分，然后每次只使用其中的一块，当第一块内存用完时，就将还存活的对象复制到第二块内存上，然后一次性清除完第一块内存，在将第二块上的对象复制到第一块。但是这种方式，<strong>内存的代价太高，每次基本上都要浪费一块内存。</strong><br>于是将该算法进行了改进，内存区域不再是按照1：1去划分，而是将内存划分为8：1：1三部分，较大的那份内存叫Eden区，其余两块较小的内存叫Survior区。每次都会先使用Eden区，若Eden区满了，就将对象赋值到Survivor区上，然后清除Eden区，如果此时存活的对象太多，以至于Survivor不够时，会将这些对象通过分配担保机制赋值到老年代中。（Java堆又分为新生代和老年代）。</p><h2 id="2-3-标记-整理算法-Mark-Compact"><a href="#2-3-标记-整理算法-Mark-Compact" class="headerlink" title="2.3. 标记-整理算法(Mark-Compact)"></a>2.3. 标记-整理算法(Mark-Compact)</h2><p>该算法是为了<strong>解决标记-清除，产生大量内存碎片的问题</strong>；当对象存活率较高时，也解决了复制算法的效率问题。它的不同之处就是在清除对象的时候现将可回收的对象移动一端，然后清除掉端边界以外的对象，这样就不会产生内存碎片。</p><h2 id="2-4-分代收集算法（Generational-Collection）"><a href="#2-4-分代收集算法（Generational-Collection）" class="headerlink" title="2.4. 分代收集算法（Generational Collection）"></a>2.4. 分代收集算法（Generational Collection）</h2><p>根据对象的存活周期的不同将内存划分为几块，一般就分为新生代和老年代，根据各个年代的特点采用不同的收集算法。新生代（少量存活）用”复制算法“；老年代（对象存活率高）“标记-清除算法”。</p><h1 id="3-Java内存模型"><a href="#3-Java内存模型" class="headerlink" title="3. Java内存模型"></a>3. Java内存模型</h1><p>内存模型如下图所示：<br><img src="/2020/07/24/Java-GC%E5%B0%8F%E7%BB%93/Java-GC%E5%B0%8F%E7%BB%93/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" srcset="/img/loading.gif" alt="Java内存模型"></p><h2 id="3-1-堆"><a href="#3-1-堆" class="headerlink" title="3.1. 堆"></a>3.1. 堆</h2><ul><li>堆是Java虚拟机所管理的内存最大一块。堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域唯一的目的就是存放对象实例。所有的对象实例都在这里分配内存。<br>堆内存分为年轻代（Young Generation）、老年代（Old Generation），年轻代又分为Eden区和Survivor区。Survivor区由FromSpace和ToSpace组成。Eden区占大容量，Survivor两个区占小容量，默认比例是8:1:1。</li><li><strong>Java堆是垃圾收集器管理的主要区域。</strong></li><li>从内存回收的角度来看，由于现在的垃圾收集器采用的是分代收集算法。所以，Java堆又分为新生代和老年代。</li><li>从内存分配的角度来说，线程共享的Java堆中可能划分出多个线程私有的fenp缓冲区(Thread Local Allocation Buffer)。</li><li>可以通过 -Xms、-Xmx分别控制堆初始化是最小堆内存和最大堆内存大小</li></ul><h2 id="3-2-虚拟机栈"><a href="#3-2-虚拟机栈" class="headerlink" title="3.2. 虚拟机栈"></a>3.2. 虚拟机栈</h2><ul><li>与程序计数器一样，Java虚拟机栈也是线程私有的，他的生命周期与线程相同。</li><li>虚拟机栈描述的是Java方法的执行的内存模型：每个方法在执行的同时会创建一个栈桢（stack frame）用于存储<strong>局部变量表、操作数栈、动态链表、方法出口等信息</strong>。每个方法从调用直至执行完成的过程，就对应着栈桢在虚拟机栈中入栈到出栈的过程。</li><li>在虚拟机规范中，对这个区域规定了两种异常情况：StackOverflowError 和 OutOfMemorryError</li></ul><h2 id="3-3-本地方法栈"><a href="#3-3-本地方法栈" class="headerlink" title="3.3. 本地方法栈"></a>3.3. 本地方法栈</h2><ul><li>与虚拟机栈发挥的作用非常类似，他们之间的区别是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的native方法服务。与虚拟机栈一样，本地方法区栈也会抛出StackOverflowError，OutOfMemorryError异常。</li></ul><h2 id="3-4-方法区（1-8后该区域被废弃）"><a href="#3-4-方法区（1-8后该区域被废弃）" class="headerlink" title="3.4. 方法区（1.8后该区域被废弃）"></a>3.4. 方法区（1.8后该区域被废弃）</h2><ul><li>方法区与Java堆一样，是各个线程所共享的，它用来存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</li><li>方法区是jvm提出的规范，而永久代就是方法区的具体实现。</li><li>Java虚拟机对方法区的限制非常宽松，可以像堆一样不需要连续的内存可可选择的固定大小外，还可以选择不识闲垃圾收集，相对而言，垃圾收集行为在这边区域是比较少出现的。</li><li>在方法区会报出 永久代内存溢出的错误。而Java1.8为了解决这个问题，就提出了meta space（元空间）的概念，就是为了解决永久代内存溢出的情况，一般来说，在不指定 meta space大小的情况下，虚拟机方法区内存大小就是宿主主机的内存大小.</li></ul><h2 id="3-5-程序计数器"><a href="#3-5-程序计数器" class="headerlink" title="3.5. 程序计数器"></a>3.5. 程序计数器</h2><ul><li>程序计数器是一块较小的内存空间，他可以看做是当前线程所执行字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选择下一条将要执行的字节码指令。</li><li>由于JAVA虚拟机的多线程是通过多线程流转切换并分配处理器执行时间的方式来实现的。<strong>在任一一个确定的时刻，一个处理器都只会执行一条线程中的指令</strong>。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各个线程的计数器之间互不影响，独立存储，我们称该类内存区域为线程私有。</li><li>如果线程正在执行一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址。</li></ul><h2 id="3-6-运行时常量池"><a href="#3-6-运行时常量池" class="headerlink" title="3.6. 运行时常量池"></a>3.6. 运行时常量池</h2><ul><li>运行时常量池是方法区的一部分。Class文件除了有类的版本、字段、方法、接口等描述信息外，还有一项是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容在类加载后进入方法区的运行时常量池。</li><li>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性。Java语言并不要求常量一定只有在编译器才能产生，依旧是并非预置入Class文件中的常量池的内容才能进入方法区运行时常量池。</li></ul><h1 id="4-Java-GC的过程。"><a href="#4-Java-GC的过程。" class="headerlink" title="4. Java GC的过程。"></a>4. Java GC的过程。</h1><p><img src="/2020/07/24/Java-GC%E5%B0%8F%E7%BB%93/Java-GC%E5%B0%8F%E7%BB%93/javaGC%E8%BF%87%E7%A8%8B.png" srcset="/img/loading.gif" alt="Java GC过程"></p><blockquote><p>1、先判断创建的对象是否可以放入栈中，若可以的话，直接放入栈中，对象使用完后，直接从栈中pop即可，不涉及GC。<br>2、若不能放入栈中，判断对象所占内存是否太大，若对象太大，则直接放入堆中的老年代，最后通过FGC（Full GC）进行回收。<br>3、对象所占内存不算太大，经过TLAB（Thread Local Allocation Buffer）后放入Eden区。<br>4、在Eden区经过GC后，放入Survior1。<br>5、在Survior1中经历GC时，判断年龄是否太大，太大则将对象放入老年区。<br>6、年龄不大，则进入Survior2。<br>7、在Survior2中经历GC时，判断年龄是否太大，太大则将对象放入老年区。<br>8、年龄不大，则进入Survior1。<br>9、重复 5~8 。</p></blockquote><h1 id="5-垃圾回收所有算法。"><a href="#5-垃圾回收所有算法。" class="headerlink" title="5. 垃圾回收所有算法。"></a>5. 垃圾回收所有算法。</h1><blockquote><p>除Epsilon ZGC Shenandoah之外的GC都是使用逻辑分代模型<br>G1是逻辑分代，物理不分代<br>除此之外不仅逻辑分代，而且物理分代</p></blockquote><p><img src="/2020/07/24/Java-GC%E5%B0%8F%E7%BB%93/Java-GC%E5%B0%8F%E7%BB%93/allGC%E7%AE%97%E6%B3%95.png" srcset="/img/loading.gif" alt="所有GC算法"></p><p>上图是10种常见的垃圾回收算法。画弧线部分表示可以组合使用，图中黄线部分是最常见的3种组合。（<strong>STW ： Stop The World 非常严重的问题</strong>）</p><h2 id="5-1-Serial。"><a href="#5-1-Serial。" class="headerlink" title="5.1. Serial。"></a>5.1. Serial。</h2><p>在GC时，由单线程进行“清理”，其他线程（业务线程等）全部停止（STW）。</p><p><img src="/2020/07/24/Java-GC%E5%B0%8F%E7%BB%93/Java-GC%E5%B0%8F%E7%BB%93/Serial.png" srcset="/img/loading.gif" alt="Serial模型"></p><h2 id="5-2-Parallel-Scaven。"><a href="#5-2-Parallel-Scaven。" class="headerlink" title="5.2. Parallel Scaven。"></a>5.2. Parallel Scaven。</h2><p>在GC时由多线程进行“清理”，  其他线程（业务线程等）全部停止（STW）。  </p><p><img src="/2020/07/24/Java-GC%E5%B0%8F%E7%BB%93/Java-GC%E5%B0%8F%E7%BB%93/ParallelScaven.png" srcset="/img/loading.gif" alt="Parallel Scaven模型"></p><h2 id="5-3-Serial-Old。"><a href="#5-3-Serial-Old。" class="headerlink" title="5.3. Serial Old。"></a>5.3. Serial Old。</h2><p>用于老年代收集垃圾的单线程GC。</p><p><img src="/2020/07/24/Java-GC%E5%B0%8F%E7%BB%93/Java-GC%E5%B0%8F%E7%BB%93/SerialOld.png" srcset="/img/loading.gif" alt="Serial Old模型"></p><h2 id="5-4-ParNew。"><a href="#5-4-ParNew。" class="headerlink" title="5.4. ParNew。"></a>5.4. ParNew。</h2><p>与Parallel Scaven类似，但它可以与CMS配合使用。</p><p><img src="/2020/07/24/Java-GC%E5%B0%8F%E7%BB%93/Java-GC%E5%B0%8F%E7%BB%93/ParNew.png" srcset="/img/loading.gif" alt="ParNew模型"></p>]]></content>
    
    
    <categories>
      
      <category>Java learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式 -- 代理模式</title>
    <link href="/2020/07/24/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/07/24/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>设计模式之代理模式，代理模式又分为静态代理和动态代理。</p><a id="more"></a><h2 id="1-代理模式UML示意图"><a href="#1-代理模式UML示意图" class="headerlink" title="1. 代理模式UML示意图"></a>1. 代理模式UML示意图</h2><p><img src="https://gitee.com/yuanlu_k/BlogImages/raw/master/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/proxyUML.jpg" srcset="/img/loading.gif" alt="代理模式"></p><blockquote><p>需要注意的有下面几点：</p><ol><li>用户(Client)只关心接口功能，而不在乎谁提供了功能。上图中接口是 Subject。</li><li>接口真正实现者是上图的 RealSubject，但是它不与用户直接接触，而是通过代理。</li><li>代理就是上图中的 Proxy，由于它实现了 Subject 接口，所以它能够直接与用户接触。</li><li>用户调用 Proxy 的时候，Proxy 内部调用了 RealSubject。所以，Proxy 是中介者，它可以增强 RealSubject 操作。</li></ol></blockquote><h2 id="2-静态代理"><a href="#2-静态代理" class="headerlink" title="2. 静态代理"></a>2. 静态代理</h2><p>静态代理在使用时,需要定义接口或者父类，<strong>被代理对象与代理对象一起实现相同的接口或者是继承相同父类</strong>。在<u>代理对象</u>中对<u>被代理对象</u>进行增强。</p><p>假设这样一个场景：有一个蛋糕店，它们卖的蛋糕都是用蛋糕机做的，而且不同种类的蛋糕由不同的蛋糕机来做，这样就有：水果蛋糕机、巧克力蛋糕机等。它们卖的面包片也是用面包机做的，同样不同种类的面包片也是由不同的面包机来做，这样就有：葡萄干面包机、红豆面包机等。这个场景用 Java 语言描述就是下面这样：</p><pre><code class="hljs java"><span class="hljs-comment">//做蛋糕的机器</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CakeMachine</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">makeCake</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//专门做水果蛋糕的机器</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FruitCakeMachine</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CakeMachine</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeCake</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"Making a fruit cake..."</span>);    &#125;&#125;<span class="hljs-comment">//专门做巧克力蛋糕的机器</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChocolateCakeMachine</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CakeMachine</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeCake</span><span class="hljs-params">()</span> </span>&#123;        System.out.printf(<span class="hljs-string">"making a Chocolate Cake..."</span>);    &#125;&#125;<span class="hljs-comment">//做面包的机器</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BreadMachine</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">makeBread</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//专门做红豆面包的机器</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedBeanBreadMachine</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BreadMachine</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeBread</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"making red bean bread...."</span>);    &#125;&#125;<span class="hljs-comment">//专门做葡萄干面包的机器</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CurrantBreadMachine</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BreadMachine</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeBread</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"making currant bread..."</span>);    &#125;&#125;<span class="hljs-comment">//蛋糕店</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CakeShop</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">new</span> FruitCakeMachine().makeCake();        <span class="hljs-keyword">new</span> ChocolateCakeMachine().makeCake();        <span class="hljs-keyword">new</span> RedBeanBreadMachine().makeBread();        <span class="hljs-keyword">new</span> CurrantBreadMachine().makeBread();    &#125;&#125;</code></pre><p>上面的代码抽象出了一个 CakeMachine 接口和 BreadMachine 接口，有各种蛋糕机（FruitCakeMachine、ChocolateCakeMachine 等）实现了 CakeMachine 接口，有各种面包机（RedBeanBreadMachine、CurrantBreadMachine 等）实现了 BreadMachine 接口，最后蛋糕店（CakeShop）直接利用这些蛋糕机做蛋糕。</p><p>这样的一个例子真实地描述了实际生活中的场景。但生活中的场景往往是复杂多变的，假设这个时候来了一个顾客，他想要一个水果蛋糕，但他特别喜欢杏仁，希望在水果蛋糕上加上一层杏仁。这时候我们应该怎么做呢？</p><p>因为我们的蛋糕机只能做水果蛋糕（程序设定好了），没办法做杏仁水果蛋糕。最简单的办法是直接修改水果蛋糕机的程序，做一台能做杏仁水果蛋糕的蛋糕机。这种方式对应的代码修改也很简单，直接在原来的代码上进行修改，生成一台专门做杏仁水果蛋糕的机器就好了，修改后的 FruitCakeMachien 类应该是这样子：</p><pre><code class="hljs java"><span class="hljs-comment">//专门做水果蛋糕的机器，并且加上一层杏仁</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FruitCakeMachine</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CakeMachine</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeCake</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"making a Fruit Cake..."</span>);        System.out.println(<span class="hljs-string">"adding apricot..."</span>);    &#125;&#125;</code></pre><p>虽然上面这种方式实现了我们的业务需求。但是仔细想一想，在现实生活中如果我们遇到这样的一个需求，我们不可能因为一个顾客的特殊需求就去修改一台蛋糕机的硬件程序，这样成本太高！而且从代码实现角度上来说，<strong>这种方式从代码上不是很优雅，修改了原来的代码</strong>。根据代码圈中<strong>「对修改封闭、对扩展开放」</strong>的思想，我们在尝试满足新的业务需求的时候应该尽量少修改原来的代码，而是在原来的代码上进行拓展。</p><p>那我们究竟应该怎么做更加合适一些呢？我们肯定是直接用水果蛋糕机做一个蛋糕，然后再人工撒上一层杏仁啦。我们需要做的，其实就是设计一个杏仁代理类（ApricotCakeProxy），这个代理类就完成撒杏仁这个动作，之后让蛋糕店直接调用即可代理类去实现即可。</p><pre><code class="hljs java"><span class="hljs-comment">//杏仁蛋糕代理</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApricotCakeProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CakeMachine</span></span>&#123;    <span class="hljs-keyword">private</span> CakeMachine cakeMachine;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ApricotCakeProxy</span><span class="hljs-params">(CakeMachine cakeMachine)</span> </span>&#123;        <span class="hljs-keyword">this</span>.cakeMachine = cakeMachine;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeCake</span><span class="hljs-params">()</span> </span>&#123;        cakeMachine.makeCake();        System.out.println(<span class="hljs-string">"adding apricot..."</span>);    &#125;&#125;<span class="hljs-comment">//蛋糕店</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CakeShop</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//可以给各种各样的蛋糕加上杏仁</span>        FruitCakeMachine fruitCakeMachine = <span class="hljs-keyword">new</span> FruitCakeMachine();        ApricotCakeProxy apricotProxy = <span class="hljs-keyword">new</span> ApricotCakeProxy(fruitCakeMachine);        apricotProxy.makeCake();        apricotProxy = <span class="hljs-keyword">new</span> ApricotCakeProxy(<span class="hljs-keyword">new</span> ChocolateCakeMachine());        apricotProxy.makeCake();    &#125;&#125;</code></pre><p>这其实就对应了即使模式中的<strong>代理模式</strong>，虽然调用的是 ApricotCakeProxy 类的方法，但实际上真正做蛋糕的是 FruitCakeMachine 类。ApricotCakeProxy 类只是在 FruitCakeMachine 做出蛋糕后，撒上一层杏仁而已。而且通过代理，我们不仅可以给水果蛋糕撒上一层杏仁，还可以给巧克力蛋糕、五仁蛋糕等撒上一层杏仁。只要它是蛋糕（实现了 CakeMachine 接口），那么我们就可以给这个蛋糕撒上杏仁。</p><p>通过代理实现这样的业务场景，这样我们就不需要在原来的类上进行修改，从而使得代码更加优雅，拓展性更强。如果下次客人喜欢葡萄干水果蛋糕了了，那可以再写一个 CurrantCakeProxy 类来撒上一层葡萄干，原来的代码也不会被修改。上面说的这种业务场景就是代理模式的实际应用，准确地说这种是<strong>静态代理。</strong></p><p>小结：<strong>静态代理模式可以在不修改被代理对象的基础上，通过扩展代理类，进行一些功能的附加与增强。值得注意的是，代理类和被代理类应该共同实现一个接口，或者是共同继承某个类。</strong></p><h2 id="3-动态代理"><a href="#3-动态代理" class="headerlink" title="3. 动态代理"></a>3. 动态代理</h2><p>业务场景的复杂度往往千变万化，如果这个特别喜欢杏仁的客人，他也想在面包上撒一层杏仁，那我们怎么办？我们能够使用之前写的 ApricotCakeProxy 代理类么？不行，因为 ApricotCakeProxy 里规定了只能为蛋糕（实现了 CakeMachine 接口）的实体做代理。这种情况下，我们只能再写一个可以为所有面包加杏仁的代理类：ApricotBreadProxy。</p><pre><code class="hljs java"><span class="hljs-comment">//杏仁面包代理</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApricotBreadProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BreadMachine</span></span>&#123;    <span class="hljs-keyword">private</span> BreadMachine breadMachine;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ApricotBreadProxy</span><span class="hljs-params">(BreadMachine breadMachine)</span> </span>&#123;        <span class="hljs-keyword">this</span>.breadMachine = breadMachine;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeBread</span><span class="hljs-params">()</span> </span>&#123;        breadMachine.makeBread();        System.out.println(<span class="hljs-string">"adding apricot..."</span>);    &#125;&#125;<span class="hljs-comment">//蛋糕店</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CakeShop</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;          <span class="hljs-comment">//可以给各种各样的面包加上杏仁</span>        RedBeanBreadMachine redBeanBreadMachine = <span class="hljs-keyword">new</span> RedBeanBreadMachine();        ApricotBreadProxy apricotBreadProxy = <span class="hljs-keyword">new</span> ApricotBreadProxy(redBeanBreadMachine);        apricotBreadProxy.makeBread();        CurrantBreadMachine currantBreadMachine = <span class="hljs-keyword">new</span> CurrantBreadMachine();        apricotBreadProxy = <span class="hljs-keyword">new</span> ApricotBreadProxy(currantBreadMachine);        apricotBreadProxy.makeBread();    &#125;&#125;</code></pre><p>最终输出结果：</p><pre><code class="hljs java">making red bean bread....adding apricot...making currant bread...adding apricot...</code></pre><p>我们可以看到我们也成功地做出了客人想要的杏仁红豆面包、杏仁葡萄干面包。</p><p>对于客人来说，他肯定希望我们所有的产品都有一层杏仁，这样客人最喜欢了。为了满足客人的需求，那如果我们的产品有 100 种（饼干、酸奶等），我们是不是得写 100 个代理类呢？有没有一种方式可以让我们只写一次实现（撒杏仁的实现），但是任何类型的产品（蛋糕、面包、饼干、酸奶等）都可以使用呢？其实在 Java 中早已经有了针对这种情况而设计的一个接口，专门用来解决类似的问题，它就是<strong>动态代理 —— InvocationHandler。</strong></p><p><strong>动态代理与静态代理的区别是静态代理只能针对特定一种产品（蛋糕、面包、饼干、酸奶）做某种代理动作（撒杏仁），而动态代理则可以对所有类型产品（蛋糕、面包、饼干、酸奶等）做某种代理动作（撒杏仁）。</strong></p><p>接下来我们针对这个业务场景做一个代码的抽象实现。首先我们分析一下可以知道这种场景的共同点是希望在所有产品上都做「撒一层杏仁」的动作，所以我们就做一个杏仁动态代理（ApricotHandler）。</p><pre><code class="hljs java"><span class="hljs-comment">//杏仁动态代理</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApricotHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span></span>&#123;    <span class="hljs-keyword">private</span> Object object;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ApricotHandler</span><span class="hljs-params">(Object object)</span> </span>&#123;        <span class="hljs-keyword">this</span>.object = object;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        Object result = method.invoke(object, args);    <span class="hljs-comment">//调用真正的蛋糕机做蛋糕</span>        System.out.println(<span class="hljs-string">"adding apricot..."</span>);        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre><p>撒杏仁的代理写完之后，我们直接让蛋糕店开工：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CakeShop</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//动态代理(可以同时给蛋糕、面包等加杏仁)</span>        <span class="hljs-comment">//给蛋糕加上杏仁</span>        FruitCakeMachine fruitCakeMachine = <span class="hljs-keyword">new</span> FruitCakeMachine();        ApricotHandler apricotHandler = <span class="hljs-keyword">new</span> ApricotHandler(fruitCakeMachine);        CakeMachine cakeMachine = (CakeMachine) Proxy.newProxyInstance(fruitCakeMachine.getClass().getClassLoader(),                fruitCakeMachine.getClass().getInterfaces(),                apricotHandler);        cakeMachine.makeCake();        <span class="hljs-comment">//给面包加上杏仁</span>        RedBeanBreadMachine redBeanBreadMachine = <span class="hljs-keyword">new</span> RedBeanBreadMachine();        apricotHandler = <span class="hljs-keyword">new</span> ApricotHandler(redBeanBreadMachine);        BreadMachine breadMachine = (BreadMachine) Proxy.newProxyInstance(redBeanBreadMachine.getClass().getClassLoader(),                redBeanBreadMachine.getClass().getInterfaces(),                apricotHandler);        breadMachine.makeBread();    &#125;&#125;</code></pre><p>输出结果为：</p><pre><code class="hljs java">making a fruit cake...adding apricot...making red bean bread....adding apricot...</code></pre><p>从输出结果可以知道，这与我们想要的结果是一致的。与静态代理相比，动态代理具有更加的普适性，能减少更多重复的代码。试想这个场景如果使用静态代理的话，我们需要对每一种类型的蛋糕机都写一个代理类（ApricotCakeProxy、ApricotBreadProxy、ApricotCookieProxy等）。但是如果使用动态代理的话，我们只需要写一个通用的撒杏仁代理类（ApricotHandler）就可以直接完成所有操作了。直接省去了写 ApricotCakeProxy、ApricotBreadProxy、ApricotCookieProxy 的功夫，极大地提高了效率。</p><p>看到这里，大家应该清楚为什么有了静态代理之后，还需要有动态代理了吧。<strong>静态代理只能针对某一接口（面包 或 蛋糕）进行操作，如果要对所有接口都（所有产品）都能做一样操作，那就必须要动态代理出马了。</strong></p><h2 id="4-如何使用动态代理？"><a href="#4-如何使用动态代理？" class="headerlink" title="4. 如何使用动态代理？"></a>4. 如何使用动态代理？</h2><p>参照上面的例子，我们可以知道要实现动态代理需要做两方面的工作。</p><ul><li>必须新建一个类，并且这个类必须实现 <strong>InvocationHandler</strong> 接口。</li></ul><pre><code class="hljs java"><span class="hljs-comment">//杏仁动态代理</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApricotHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span></span>&#123;    <span class="hljs-keyword">private</span> Object object;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ApricotHandler</span><span class="hljs-params">(Object object)</span> </span>&#123;        <span class="hljs-keyword">this</span>.object = object;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        Object result = method.invoke(object, args);    <span class="hljs-comment">//调用真正的蛋糕机做蛋糕</span>        System.out.println(<span class="hljs-string">"adding apricot..."</span>);        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre><ul><li>在调用的时候使用 Proxy.newProxyInstance() 方法生成代理类。</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CakeShop</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//给蛋糕加上杏仁</span>        FruitCakeMachine fruitCakeMachine = <span class="hljs-keyword">new</span> FruitCakeMachine();        ApricotHandler apricotHandler = <span class="hljs-keyword">new</span> ApricotHandler(fruitCakeMachine);        CakeMachine cakeMachine = (CakeMachine) Proxy.newProxyInstance(fruitCakeMachine.getClass().getClassLoader(),                fruitCakeMachine.getClass().getInterfaces(),                apricotHandler);        cakeMachine.makeCake();&#125;</code></pre><ul><li>最后直接使用生成的代理类调用相关的方法即可。</li></ul><p>Tips:</p><pre><code class="hljs java"><span class="hljs-comment">/** </span><span class="hljs-comment">  * Proxy</span><span class="hljs-comment">  * 动态代理的语法</span><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> loader 自然是类加载器</span><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> interfaces 代码要用来代理的接口</span><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> h 一个InvocationHandler对象</span><span class="hljs-comment">  * <span class="hljs-doctag">@return</span> 代理对象</span><span class="hljs-comment">  */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">newProxyInstance</span><span class="hljs-params">(ClassLoader loader,</span></span><span class="hljs-function"><span class="hljs-params">                                          Class&lt;?&gt;[] interfaces,</span></span><span class="hljs-function"><span class="hljs-params">                                          InvocationHandler h)</span></span></code></pre><pre><code class="hljs java"><span class="hljs-comment">//InvocationHandler</span><span class="hljs-comment">//InvocationHandler 是一个接口，官方文档解释说，每个代理的实例都有一个与之关联的 InvocationHandler 实现类，如果代理的方法被调用，那么代理便会通知和转发给内部的 InvocationHandler 实现类，由它决定处理。</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment">  * 内部只是一个 invoke() 方法，正是这个方法决定了怎么样处理代理传递过来的方法调用。</span><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> proxy 代理对象</span><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> method 代理对象调用的方法</span><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> args 调用方法中的参数</span><span class="hljs-comment">  * <span class="hljs-doctag">@return</span> </span><span class="hljs-comment">  */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable</span>;&#125;</code></pre><h2 id="5-动态代理的几种实现方式"><a href="#5-动态代理的几种实现方式" class="headerlink" title="5. 动态代理的几种实现方式"></a>5. 动态代理的几种实现方式</h2><p>动态代理其实指的是一种设计模式概念，指的是通过代理来做一些通用的事情，常见的应用有权限系统、日志系统等，都用到了动态代理。</p><p>而 <strong>Java 动态代理只是动态代理的一种实现方式而已</strong>，动态代理还有另外一种实现方式，即 <strong>CGLib</strong>（Code Generation Library）。</p><p>Java 动态代理只能<strong>针对实现了接口的类进行拓展</strong>，所以细心的朋友会发现我们的代码里有一个叫 MachineCake 的接口。而 CGLib 则没有这个限制，因为 CGLib 是使用继承原有类的方式来实现代理的。</p><p>我们还是举个例子来说明 <strong>CGLib 是如何实现动态代理的</strong>吧。还是前面的例子：我们要做杏仁水果蛋糕、巧克力水果蛋糕、五仁巧克力蛋糕，这时候用代码描述是这样的。</p><p>首先我们需要写一个杏仁拦截器类，这个拦截器可以给做好的蛋糕加上杏仁。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApricotInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        methodProxy.invokeSuper(o, objects);        System.out.println(<span class="hljs-string">"adding apricot..."</span>);        <span class="hljs-keyword">return</span> o;    &#125;&#125;</code></pre><p>接着直接让蛋糕店使用 CGLib 提供的工具类做杏仁水果蛋糕：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CakeShop</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;         <span class="hljs-comment">//CGLib动态代理(可以同时给蛋糕、面包等加杏仁)</span>        Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();        enhancer.setSuperclass(FruitCakeMachine<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        enhancer.setCallback(<span class="hljs-keyword">new</span> ApricotInterceptor());        FruitCakeMachine fruitCakeMachine = (FruitCakeMachine) enhancer.create();        fruitCakeMachine.makeCake();    &#125;&#125;</code></pre><p>上面的 enhancer.setSuperClass() 设置需要增强的类，而 enhancer.setCallback() 则设置需要回调的拦截器，即实现了 MethodInterceptor 接口的类。最后最后使用 enhancer.create() 生成了对应的增强类，最后输出结果为：</p><pre><code class="hljs java">making a fruit cake...adding apricot...</code></pre><p>和我们预期的一样。如果要做一个杏仁面包片，那么直接让蛋糕店利用ApricotHandler 再做一个就可以了，它们的区别只是传入的增强类不同。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CakeShop</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;           <span class="hljs-comment">//做一个杏仁面包片</span>          Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();        enhancer.setSuperclass(RedBeanBreadMachine<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        enhancer.setCallback(<span class="hljs-keyword">new</span> ApricotInterceptor());        RedBeanBreadMachine chocolateCakeMachine = (RedBeanBreadMachine) enhancer.create();        chocolateCakeMachine.makeBread();    &#125;&#125;</code></pre><p>可以看到，这里传入的增强类是 RedBeanBreadMachine，而不是之前的 FruitCakeMachine。</p><p>对比 Java 动态代理和 CGLib 动态代理两种实现方式，你会发现 <strong>Java 动态代理适合于那些有接口抽象的类代理，而 CGLib 则适合那些没有接口抽象的类代理。</strong></p><h3 id="5-1-Java动态代理的原理"><a href="#5-1-Java动态代理的原理" class="headerlink" title="5.1. Java动态代理的原理"></a>5.1. Java动态代理的原理</h3><p>从上面的例子我们可以知道，Java 动态代理的入口是从 Proxy.newInstance() 方法中开始的，通过这个方法，Java 替我们生成了一个继承了指定接口（CakeMachine）的代理类（ApricotHandler）实例。Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) 方法简单来说执行了以下操作：</p><blockquote><p> 1、生成一个实现了参数 interfaces 里所有接口且继承了 Proxy 的代理类的字节码，然后用参数里的 classLoader 加载这个代理类。<br>2、使用代理类父类的构造函数 Proxy(InvocationHandler h) 来创造一个代理类的实例，将我们自定义的 InvocationHandler 的子类传入。<br>3、返回这个代理类实例，因为我们构造的代理类实现了 interfaces（也就是我们程序中传入的 fruitCakeMachine.getClass().getInterfaces() 里的所有接口，因此返回的代理类可以强转成 MachineCake 类型来调用接口中定义的方法。</p></blockquote><h3 id="5-2-CGLib动态代理的原理"><a href="#5-2-CGLib动态代理的原理" class="headerlink" title="5.2 CGLib动态代理的原理"></a>5.2 CGLib动态代理的原理</h3><p>因为 JVM 并不允许在运行时修改原有类，所以所有的动态性都是通过新建类来实现的，上面说到的 Java 动态代理也不例外。所以对于 CGLib 动态代理的原理，其实也是通过动态生成代理类，最后由代理类来完成操作实现的。</p><p>对于 CGLib 动态代理的实现，我并没有深入到源码中，而是通过查阅资料了解了其大概的实现原理。</p><ul><li>首先，我们在使用的时候通过 enhancer.setSuperclass(FruitCakeMachine.class) 传入了需要增加的类，CGLib 便会生成一个继承了该类的代理类。</li><li>接着，我们通过 enhancer.setCallback(new ApricotInterceptor()) 传入了代理类对象，CGLib 通过组装两个类的结构实现一个静态代理，从而达到具体的目的。</li></ul><p>而在 CGLib 生成新类的过程中，其使用的是一个名为 ASM 的东西，它对 Java 的 class 文件进行操作、生成新的 class 文件。如果你对 CGLib 的原理感兴趣，不妨看看这篇文章：<a href="https://www.zhihu.com/question/从兄弟到父子：动态代理在民间是怎么玩的？" target="_blank" rel="noopener">从兄弟到父子：动态代理在民间是怎么玩的？</a></p><h2 id="6-动态代理的应用"><a href="#6-动态代理的应用" class="headerlink" title="6. 动态代理的应用"></a>6. 动态代理的应用</h2><p>动态代理在代码界可是有非常重要的意义，我们开发用到的许多框架都使用到了这个概念。我所知道的就有：Spring AOP、Hibernate、Struts 使用到了动态代理。</p><ul><li><strong>Spring AOP。</strong>Spring 最重要的一个特性是 AOP（Aspect Oriented Programming 面向切面编程），利用 Spring AOP 可以快速地实现权限校验、安全校验等公用操作。而 Spring AOP 的原理则是通过动态代理实现的，默认情况下 Spring AOP 会采用 Java 动态代理实现，而当该类没有对应接口时才会使用 CGLib 动态代理实现。</li><li><strong>Hibernate。</strong>Hibernate 是一个常用的 ORM 层框架，在获取数据时常用的操作有：get() 和 load() 方法，它们的区别是：get() 方法会直接获取数据，而 load() 方法则会延迟加载，等到用户真的去取数据的时候才利用代理类去读数据库。</li><li><strong>Struts。</strong>Struts 现在虽然因为其太多 bug 已经被抛弃，但是曾经用过 Struts 的人都知道 Struts 中的拦截器。拦截器有非常强的 AOP 特性，仔细了解之后你会发现 Struts 拦截器其实也是用动态代理实现的。</li></ul><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>我们通过蛋糕店的不同业务场景介绍了静态代理和动态代理的应用，接着重点介绍了动态代理两种实现方式（Java 动态代理、CGLib 动态代理）的使用方法及其实现原理，其中还针对 Java 动态代理的源码进行了简单的分析。最后，我们介绍了动态代理在实际上编程中的应用（Spring AOP、Hibernate、Struts）。</p><p>希望这篇文章帮助大家更好地理解动态代理。</p><p>参考：<a href><a href="https://www.cnblogs.com/chanshuyi/p/deep_insight_java_proxy_pattern.html">Java动态代理：一个面包店的动态代理帝国</a></a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
