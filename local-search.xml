<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>手动实现热加载</title>
    <link href="/2020/08/29/%E7%83%AD%E5%8A%A0%E8%BD%BD/"/>
    <url>/2020/08/29/%E7%83%AD%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<p><strong>热加载</strong>相关知识，欢迎交流，指证错误。</p><a id="more"></a><h3 id="1-什么是热加载"><a href="#1-什么是热加载" class="headerlink" title="1. 什么是热加载"></a>1. 什么是热加载</h3><p><strong>热加载</strong>是指可以在不重启服务的情况下让更改的代码生效，<strong>热加载</strong>可以显著的提升开发以及调试的效率，它是基于 Java 的类加载器实现的，但是由于热加载的不安全性，一般不会用于正式的生产环境。</p><h3 id="2-热加载与热部署的区别"><a href="#2-热加载与热部署的区别" class="headerlink" title="2. 热加载与热部署的区别"></a>2. 热加载与热部署的区别</h3><p>首先，不管是<strong>热加载</strong>还是<strong>热部署</strong>，都可以在不重启服务的情况下编译/部署项目，都是基于 Java 的类加载器实现的。</p><p>两者之间的区别：</p><ol><li>在部署方式上：</li></ol><ul><li>热部署是在服务器运行时<strong>重新部署</strong>项目。</li><li>热加载是在运行时<strong>重新加载 class文件</strong>。</li></ul><ol start="2"><li>在实现原理上：</li></ol><ul><li>热部署是直接重新<strong>加载整个应用</strong>，耗时相对较高。</li><li>热加载是在运行时<strong>重新加载 class文件</strong>，后台会启动一个线程不断检测你的类是否改变。</li></ul><ol start="3"><li>在使用场景上：</li></ol><ul><li>热部署更多的是在<strong>生产环境</strong>使用。</li><li>热加载则更多的是在<strong>开发环境</strong>上使用。线上由于安全性问题不会使用，难以监控。</li></ul><h3 id="3-类加载五个阶段"><a href="#3-类加载五个阶段" class="headerlink" title="3. 类加载五个阶段"></a>3. 类加载五个阶段</h3><blockquote><ol><li>加载阶段：找到类的静态存储结构，加载到虚拟机，定义数据结构。用户可以自定义类加载器。</li><li>验证阶段：确保字节码是安全的，确保不会对虚拟机的安全造成危害。</li><li>准备阶段：确定内存布局，确定内存遍历，赋<strong>初始值</strong>（注意：是初始值，也有特殊情况）。</li><li>解析阶段： 将符号变成直接引用。</li><li>初始化阶段：调用程序自定义的代码。规定有且仅有5种情况必须进行初始化。<ol><li>new（实例化对象）、getstatic（获取类变量的值，被final修饰的除外，他的值在编译器时放到了常量池）、putstatic（给类变量赋值）、invokestatic（调用静态方法） 时会初始化</li><li>调用子类的时候，发现父类还没有初始化，则父类需要立即初始化。</li><li>虚拟机启动，用户要执行的主类，主类需要立即初始化，如 main 方法。</li><li>使用 java.lang.reflect包的方法对类进行反射调用方法 是会初始化。</li><li>当使用JDK 1.7的动态语言支持时， 如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、 REF_putStatic、 REF_invokeStatic的方法句柄， 并且这个方法句柄所对应的类没有进行过初始化， 则需要先触发其初始化。</li></ol></li></ol></blockquote><p>要说明的是，类加载的 5 个阶段中，只有<strong>加载阶段</strong>是用户可以自定义处理的，而验证阶段、准备阶段、解析阶段、初始化阶段都是用 JVM 来处理的。</p><h3 id="4-实现类的热加载"><a href="#4-实现类的热加载" class="headerlink" title="4. 实现类的热加载"></a>4. 实现类的热加载</h3><h4 id="4-1-基本思路"><a href="#4-1-基本思路" class="headerlink" title="4.1. 基本思路"></a>4.1. 基本思路</h4><p>由类加载的五个阶段可知，只有在<strong>加载阶段</strong>用户才可以自定义处理，因此如果由文件监视器实时监测class文件，若如class文件发生改变则将class文件重新加载到虚拟机，就可以简单实现类的热加载。</p><blockquote><p>基本步骤：</p><ul><li>自定义类加载器</li><li>指定需要热加载的类</li><li>利用文件监视器实时监测class文件</li><li>class发生改变，重新加载</li></ul></blockquote><h4 id="4-2-自定义类加载器"><a href="#4-2-自定义类加载器" class="headerlink" title="4.2. 自定义类加载器"></a>4.2. 自定义类加载器</h4><p>设计 Java 虚拟机的团队把类的加载阶段放到的 JVM 的外部实现（ 通过一个类的全限定名来获取描述此类的二进制字节流 ）。这样就可以让程序自己决定如果获取到类信息。而实现这个加载动作的代码模块，我们就称之为 “类加载器”。</p><p>在 Java 中，类加载器也就是 <code>java.lang.ClassLoader</code>. 所以如果我们想要自己实现一个类加载器，就需要继承 <code>ClassLoader</code> 。</p><p>接下来看看<code>ClassLoader</code>中的主要方法：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassLoader</span> </span>&#123;    <span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;        <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;            <span class="hljs-comment">// 首先，监测是否已经加载</span>            Class&lt;?&gt; c = findLoadedClass(name);            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">long</span> t0 = System.nanoTime();                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;                        <span class="hljs-comment">//父加载器不为null的话调用父加载器的loadClass</span>                        c = parent.loadClass(name, <span class="hljs-keyword">false</span>);                    &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-comment">//父加载器为null 则调用 Bootstrap ClassLoader</span>                        c = findBootstrapClassOrNull(name);                    &#125;                &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;                    <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span>                    <span class="hljs-comment">// from the non-null parent class loader</span>                &#125;                <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-comment">// If still not found, then invoke findClass in order</span>                    <span class="hljs-comment">// to find the class.</span>                    <span class="hljs-keyword">long</span> t1 = System.nanoTime();                    <span class="hljs-comment">//父加载器没有找到，则调用findclass</span>                    c = findClass(name);                    <span class="hljs-comment">// this is the defining class loader; record the stats</span>                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                    sun.misc.PerfCounter.getFindClasses().increment();                &#125;            &#125;            <span class="hljs-keyword">if</span> (resolve) &#123;                resolveClass(c);            &#125;            <span class="hljs-keyword">return</span> c;        &#125;    &#125;        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Class&lt;?&gt; findLoadedClass(String name) &#123;        <span class="hljs-keyword">if</span> (!checkName(name))            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-comment">// 检测这个class是不是已经加载过了</span>        <span class="hljs-keyword">return</span> findLoadedClass0(name);    &#125;        <span class="hljs-comment">// 它能将class二进制内容转换成Class对象，如果不符合要求的会抛出各种异常</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Class&lt;?&gt; defineClass(<span class="hljs-keyword">byte</span>[] b, <span class="hljs-keyword">int</span> off, <span class="hljs-keyword">int</span> len) <span class="hljs-keyword">throws</span> ClassFormatError &#123;        <span class="hljs-keyword">return</span> defineClass(<span class="hljs-keyword">null</span>, b, off, len, <span class="hljs-keyword">null</span>);    &#125;    &#125;</code></pre><p>由<code>ClassLoader#defineClass</code>可知，class文件可通过二进制形式转换为Class对象，并且在会在当前的<code>ClassLoader</code>中缓存该class已被加载，即通过<code>ClassLoader#findLoadedClass</code>方法检测出来。</p><p><strong>自定义ClassLoader：</strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> harrison</span><span class="hljs-comment"> * 自定义ClassLoader</span><span class="hljs-comment"> * 作用：将自己指定目录下  更新的class文件  动态加载到JVM中</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassLoader</span> </span>&#123;    <span class="hljs-comment">// 项目根目录</span>    <span class="hljs-keyword">public</span> String rootPath;    <span class="hljs-comment">// 需要热加载的 class 记录， 因为有些类是不需要我们加载的  比如 String</span>    <span class="hljs-keyword">public</span> List&lt;String&gt; clazzs;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 传入指定目录  热加载class文件</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> rootPath 项目的根目录，需要根据此目录来截取class文件路径  因为加载的是class问价， </span><span class="hljs-comment">     * 其目录为： D://projects//com/xx/X.class</span><span class="hljs-comment">     * 但是classLoader需要根据ClassName加载，而className的格式为 com.xx.X,所以需要根据路径截取到com这一截</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> clazzPaths 需要热加载的项目</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClassLoader</span><span class="hljs-params">(String rootPath, String... clazzPaths)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        <span class="hljs-keyword">this</span>.rootPath = rootPath;        <span class="hljs-keyword">this</span>.clazzs = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span>(String clazzPath : clazzPaths)&#123;            LoadClassPath(<span class="hljs-keyword">new</span> File(clazzPath));        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据目录扫描项目里的class文件 并把文件加载进JVM</span><span class="hljs-comment">     * defineClass() 此方法为ClassLoader的方法</span><span class="hljs-comment">     * 此方法传入一个className 与 byte数组(byte数组是对应Class文件的二进制数据数组) 来将对应的Class文件加载进JVM， 并生成Class对象</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> file 出入扫描的目录</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LoadClassPath</span><span class="hljs-params">(File file)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        <span class="hljs-keyword">if</span>(file.isDirectory())&#123;            <span class="hljs-keyword">for</span>(File f : file.listFiles())&#123;                LoadClassPath(f);            &#125;        &#125;<span class="hljs-keyword">else</span> &#123;            String fileName = file.getName();            String filePath = file.getPath();            String endName = fileName.substring(fileName.lastIndexOf(<span class="hljs-string">"."</span>) + <span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span>(<span class="hljs-string">"class"</span>.equals(endName))&#123;                InputStream in = <span class="hljs-keyword">new</span> FileInputStream(file);                <span class="hljs-keyword">byte</span>[] bytes =<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[(<span class="hljs-keyword">int</span>)file.length()];                in.read(bytes);                String className = filePathTOClassName(filePath);                clazzs.add(className);                <span class="hljs-comment">// 将class文件生成class对象</span>                defineClass(className, bytes, <span class="hljs-number">0</span>, bytes.length);            &#125;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 将文件路径替换为ClassName</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> filePath 文件路径</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">filePathTOClassName</span><span class="hljs-params">(String filePath)</span> </span>&#123;        String className = filePath.replace(rootPath, <span class="hljs-string">""</span>).replaceAll(<span class="hljs-string">"\\\\"</span>, <span class="hljs-string">"."</span>);        className = className.substring(<span class="hljs-number">0</span>, className.lastIndexOf(<span class="hljs-string">"."</span>));        className = className.substring(<span class="hljs-number">1</span>);        <span class="hljs-keyword">return</span> className;    &#125;&#125;</code></pre><p><code>ClassLoader</code>类中可以看到类加载采用“双亲委派机制”，并且自定义的<code>MyClassLoader</code>的父加载器默认为<code>AppClassLoader</code>,因此如果是这样的话，依旧采用的“双亲委派机制”来加载类，无法达到热加载的效果。故我们需要指定自定义的<code>MyClassLoader</code>来加载。这里涉及到<strong>全盘委托</strong>。</p><blockquote><p> 全盘委托：首先要用哪个类加载器。</p><p>是利用当前方法（或者说当前类）的类加载器作为优先的类加载器。</p><p>例如：<code>User</code>对象调用<code>setAddress()</code>方法，而在<code>setAddress()</code>方法中对<code>Address</code>类进行实例化( <code>new Address()</code>)，则<code>Address</code>将<strong>优先选择</strong>加载<code>User</code>的类加载器来加载<code>Address</code>，即如果<code>User</code>是<code>AppClassLoader</code>加载，则<strong>依据全盘委托</strong>，<code>Address</code>也是优先选择<code>AppClassLoader</code>进行加载，但最终由哪个类加载器加载，还是由<strong>双亲委派机制</strong>决定。假设在<code>User</code>对象中实例化了一个<code>String</code>对象，则会优先选择<code>AppClassLoader</code>加载<code>String</code>，但是由于双亲委派机制最终<code>String</code>由<code>Bootstrap ClassLoader</code>加载。</p><p>双亲委派机制：最终用哪个类加载器来加载类。</p></blockquote><p>因此依据<strong>全盘委托</strong>我们自己自定义的优先选择类加载器，但是最终选择哪个类加载器还是不确定的。基于此我们可以让自定义的<code>CLassLoader</code>在加载class不经历<strong>双亲委派</strong>，那不就是优先选择谁，谁就是最终的类加载器么。</p><p>因此在加载给定目录下的类时，我们先把class文件读取成二进制数组，然后调用<code>defineClass()</code>就可以把class加载进JVM，且不经历双亲委派（如MyClassLoader#LoadClassPath方法所示）。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FileAlterationListenerAdaptor</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Application application;    <span class="hljs-comment">// 需要热加载类的根目录</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String rootPath;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Application</span><span class="hljs-params">()</span></span>&#123;        Application.application = <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        <span class="hljs-comment">//类似于SpringBoot启动流程。。。</span>        init();        <span class="hljs-comment">// logic code</span>        <span class="hljs-keyword">new</span> User().sayHello();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"初始化项目。"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        String rootPath = clazz.getResource(<span class="hljs-string">"/"</span>).getPath().replaceAll(<span class="hljs-string">"%20"</span>, <span class="hljs-string">" "</span>);        rootPath = <span class="hljs-keyword">new</span> File(rootPath).getPath();        Application.rootPath = rootPath;        startFileMoni(rootPath);        MyClassLoader myClassLoader = <span class="hljs-keyword">new</span> MyClassLoader(rootPath, rootPath + <span class="hljs-string">"/com/harrison"</span>);        start0(myClassLoader);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Application 由自定义的类加载加载，因此在Application中实例化的对象都会优先选择自定义的类加载器</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> myClassLoader 自定义类加载器</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start0</span><span class="hljs-params">(MyClassLoader myClassLoader)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        <span class="hljs-comment">// loadClass(String name) 参数name是class的全限定名</span>        Class&lt;?&gt; aClass = myClassLoader.loadClass(<span class="hljs-string">"com.harrison.Application"</span>);        Object o = aClass.newInstance();        aClass.getMethod(<span class="hljs-string">"start"</span>).invoke(o);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"关闭项目"</span>);        <span class="hljs-comment">//通知JVM销毁已失去引用的对象(执行finalize()方法)</span>        System.runFinalization();        <span class="hljs-comment">//通知JVM GC</span>        System.gc();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     *  启动文件监听器</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> rootPath</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startFileMoni</span><span class="hljs-params">(String rootPath)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        FileAlterationObserver fileAlterationObserver = <span class="hljs-keyword">new</span> FileAlterationObserver(rootPath);        fileAlterationObserver.addListener(<span class="hljs-keyword">new</span> FileListener());        FileAlterationMonitor fileAlterationMonitor = <span class="hljs-keyword">new</span> FileAlterationMonitor(<span class="hljs-number">500</span>);        fileAlterationMonitor.addObserver(fileAlterationObserver);        fileAlterationMonitor.start();    &#125;&#125;</code></pre><p><code>Application</code>类由自定义的ClassLoader加载，则在<code>Application</code>中实例化的对象都将有自定义的<code>MyClassLoader</code>加载。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FileAlterationListenerAdaptor</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFileChange</span><span class="hljs-params">(File file)</span> </span>&#123;        <span class="hljs-keyword">if</span>(file.getName().indexOf(<span class="hljs-string">".class"</span>) != -<span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">// 热部署</span>                Application.close();                MyClassLoader myClassLoader = <span class="hljs-keyword">new</span> MyClassLoader(Application.rootPath, Application.rootPath + <span class="hljs-string">"/com/harrison"</span>);                Application.start0(myClassLoader);            &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre><p>文件监听器，class文件发生改变，则会重新加载class文件。</p><p>测试：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;    Application.run(MyClassLoader<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    &#125;&#125;</code></pre><p>经过测试发现，当User中的<code>sayHello()</code>方法改变时，重新编译，即可执行更改后的代码，证明实现了热加载。</p><p>上述source code可在<a href="https://github.com/kangkanglang/JavaLearning/tree/master/ClassLoaderTest" target="_blank" rel="noopener">我的github</a>上进行预览。</p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><ul><li>CLassLoader中的三个重要的方法<code>loadClass()</code>、<code>findLoadedClass()</code>、<code>defineClass()</code>以及它们的作用。</li><li>全盘委托 和 双亲委派， 以及二者之间的区别。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Learning</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组中数字出现的次数</title>
    <link href="/2020/08/23/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
    <url>/2020/08/23/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>记录Leetcode上的一道题目，欢迎交流，指证错误。</p><a id="more"></a><h3 id="1-普通版"><a href="#1-普通版" class="headerlink" title="1. 普通版"></a>1. 普通版</h3><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">LeetCode链接</a></p><p><strong>题目：</strong></p><p>一个整型数组 <code>nums</code>里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：nums = [4,1,4,6]<br>输出：[1,6] 或 [6,1]</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p> 输入：nums = [1,2,10,4,1,4,3,3]<br>输出：[2,10] 或 [10,2]</p></blockquote><p><strong>限制：</strong></p><blockquote><p> 2 &lt;= nums.length &lt;= 10000</p></blockquote><p><strong>解题思路：</strong></p><p>如果不考虑空间复杂度的话，可以考虑用map来完成，数组中的数字为key，出现的次数为value。要求时间复杂度为O(n)，空间复杂度为O(1)。</p><p>我们知道：两个相同的数字进行异或运算结果为<code>0</code>，任何数字与<code>0</code>异或运算结果为数字本身。若数组中只有一个数字只出现一次的话，则将所有数字直接异或运算，就能得到只出现一次的数字。现在数组中有两个只出现了一次的数字，则可以考虑将数组分成2块，让每一块中保证只有一个数字出现一次。</p><p>接下来只需考虑如何将数组分成2块:</p><blockquote><ul><li>重复的数字进行分组，很简单，只需要有一个统一的规则，就可以把相同的数字分到同一组了。例如：奇偶分组。因为重复的数字，数值都是一样的，所以一定会分到同一组！</li><li>两个不同数字的分组，假设为数字a，b。若我们将所有数字进行异或运算，得到数字k，则得到的k应该为数字a与b的异或结果。因为相同的数字异或结果为<code>0</code>，而任何数与<code>0</code>异或的结果为自身。对于数字k的二进制来说，若二进制中第一位数字1，则表示数字a和b的二进制中第一位不同（因为<code>0</code>与<code>1</code>异或为<code>1</code>，<code>0</code>与<code>0</code>异或为 0，<code>1</code>与<code>1</code>异或为0）。因此只要找到k的二进制数种任意一位为<code>1</code>，即可将a和b进行区分。</li></ul></blockquote><p><strong>代码：</strong></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] singleNumbers(<span class="hljs-keyword">int</span>[] nums) &#123;        <span class="hljs-comment">//用于将所有的数异或起来</span>        <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num: nums) &#123;            k ^= num;        &#125;        <span class="hljs-comment">//这里 从最低位开始找k中的1</span>        <span class="hljs-keyword">int</span> mask = <span class="hljs-number">1</span>;        <span class="hljs-comment">//(k &amp; mask) == 1时表示已找到k中最低位的1，存于mask中，我们假设在index这个位为1</span>        <span class="hljs-keyword">while</span>((k &amp; mask) == <span class="hljs-number">0</span>) &#123;            mask &lt;&lt;= <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> b = <span class="hljs-number">0</span>; <span class="hljs-comment">//这里 让index位为0的数字和a分到一组，index位为1的分为一组（这里没有采用奇偶分组）</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num: nums) &#123;            <span class="hljs-keyword">if</span>((num &amp; mask) == <span class="hljs-number">0</span>) &#123;                a ^= num;            &#125; <span class="hljs-keyword">else</span> &#123;                b ^= num;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;a, b&#125;;    &#125;&#125;</code></pre><h3 id="2-进阶版"><a href="#2-进阶版" class="headerlink" title="2. 进阶版"></a>2. 进阶版</h3><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/" target="_blank" rel="noopener">LeetCode链接</a></p><p><strong>题目：</strong></p><p>在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：nums = [3,4,3,3]<br>输出：4</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p> 输入：nums = [9,1,7,9,7,9,7]<br>输出：1</p></blockquote><p><strong>限制：</strong></p><blockquote><p>1 &lt;= nums.length &lt;= 10000<br>1 &lt;= nums[i] &lt; 2^31</p></blockquote><p><strong>解题思路（源于剑指Offer）：</strong></p><p>这次是只有一个数字只出现了一次，但其他数字却出现了3次，因此也不能直接把所有数字进行异或运算，从而求出不一样的数字。<strong>如果一个数字出现三次,那么它的二进制表示的每一位(0或者1)也出现三次，则把所有出现三次的数字的二进制表示的每一位都分别加起来,那么每一位的和都能被3整除。如果某一位的和能被3整除,那么那个只出现一次的数字二进制表示中对应的那一位是0;否则就是1;</strong></p><p><strong>上述思路同样适用于数组中一个数字出现一次，其他数字出现奇数次问题(如果是偶数次，直接用异或就可)。</strong></p><p><strong>代码：</strong></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-comment">//在java语言中，一个int数字4字节，32位。</span>        <span class="hljs-comment">//sums 统计结果</span>        <span class="hljs-keyword">int</span>[] sums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">32</span>];        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++)&#123;            <span class="hljs-keyword">int</span> mask = <span class="hljs-number">1</span> &lt;&lt; i;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; nums.length; j++)&#123;                <span class="hljs-comment">//(mask &amp; nums[j]) == mask 表示nums[j]的二进制中第i位为1</span>                <span class="hljs-keyword">if</span>((mask &amp; nums[j]) == mask) sums[i] += <span class="hljs-number">1</span>;            &#125;            sums[i] %= <span class="hljs-number">3</span>;            <span class="hljs-keyword">if</span>(sums[i] == <span class="hljs-number">1</span>) result += mask;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre><h3 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h3><p><strong>Java中的位运算：</strong></p><blockquote><ul><li>与（&amp;）运算：<code>1 &amp; 1 为 1; 1 &amp; 0 为 0; 0 &amp; 1 为 0； 0 &amp; 0 为 0 。</code></li><li>或（|）运算：<code>1 | 1 为 1; 1 | 0 为 1; 0 | 1 为 1； 0 | 0 为 0 。</code></li><li>非（<del>）运算：`</del> 1 为 0; ~ 0 为 1 。`</li><li>异或（^）运算：<code>1 ^ 1 为 0; 1 ^ 0 为 1; 0 ^ 1 为 1； 0 ^ 0 为 0 。</code></li></ul></blockquote><p><code>Java</code> 可在整数类型（<em><code>integral type</code></em>）数据上进行位（<em><code>bit</code></em>）运算</p><p>整数类型：</p><ul><li>字节型(<code>byte</code>，<code>8</code> 位)</li><li>短整型(<code>short</code>，<code>16</code> 位)</li><li>整型(<code>int</code>，<code>32</code> 位)</li><li>长整型(<code>long</code>，<code>64</code> 位)</li></ul><p><strong>Java中的移位运算：</strong></p><blockquote><ul><li>左移运算符（<code>&lt;&lt;</code>）：丢弃最高位，0补最低位；<code>4 &lt;&lt; 2 为 16; -4 &lt;&lt; 2 为 -16</code></li><li>右移运算符（<code>&gt;&gt;</code>）：符号位不变，左边补上符号位； <code>4 &gt;&gt; 2 为 1; -4 &gt;&gt; 2 为 -1</code></li><li>无符号右移运算符（<code>&gt;&gt;&gt;</code>）：忽略了符号位扩展，0补最高位；</li></ul></blockquote><p>PS:无符号右移规则和右移运算是一样的，只是填充时不管左边的数字是正是负都用0来填充，无符号右移运算只针对负数计算，因为对于正数来说这种运算没有意义</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IOC容器注入Bean的方式</title>
    <link href="/2020/08/19/IOC%E5%AE%B9%E5%99%A8%E6%B3%A8%E5%85%A5Bean%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <url>/2020/08/19/IOC%E5%AE%B9%E5%99%A8%E6%B3%A8%E5%85%A5Bean%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>IOC容器注入Bean的方式，欢迎交流，指证错误。</p><a id="more"></a><p>Spring提供的主要功能就是对于Bean的管理，提供了多种方式可以向容器中注入Bean，下面总结一下向IOC容器注入Bean的几种方式（以下注入Bean的方式都是基于注解完成的）：</p><h3 id="1-ComponentScan-Component方式"><a href="#1-ComponentScan-Component方式" class="headerlink" title="1. @ComponentScan+@Component方式"></a>1. @ComponentScan+@Component方式</h3><p>@ComponentScan可以扫描指定包下的类，如果该包下的类标有@Component、@Service、@Repository、@Controller、@RestController和@Configuration，都会被注入到IOC容器中，这种方式也是我们写代码最常用的，<strong>一般针对自己写的类。</strong></p><p> 我们写的配置类，在上面标有@ComponentScan，指定扫描的的包，这时被扫描的类需要提供无参构造方法，不然会报错。</p><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan</span>(basePackages = &#123;<span class="hljs-string">"com.harrison"</span>&#125;)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123; &#125;</code></pre><p>若在 com.harrison 包下有User类，则在User类上添加@Component即可将User注入IOC容器。</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.harrison.pojo; <span class="hljs-keyword">import</span> org.springframework.stereotype.Component; <span class="hljs-comment">//使用这种方式需要替换无参构造的方法，因为spring是调用无参构造方法创建类的</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;        <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span> </span>&#123;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name, Integer age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.age = age;    &#125;     <span class="hljs-comment">// Getter and Setter methods</span> &#125;</code></pre><h3 id="2-使用-Configuration-Bean注解"><a href="#2-使用-Configuration-Bean注解" class="headerlink" title="2. 使用@Configuration + @Bean注解"></a>2. 使用@Configuration + @Bean注解</h3><p>该方法一般用于导入的第三方包里面的组件，因为第三方包里面没有添加Spring相关的注解，所以使用第一种方式就不行了。</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserConfig</span> </span>&#123;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 使用<span class="hljs-doctag">@Bean</span>方式向容器注入Bean，适用于导入的第三方包里面的组件</span><span class="hljs-comment">     * 在<span class="hljs-doctag">@Bean</span>后面不跟其他属性时，Bean的名称默认使用方法名</span><span class="hljs-comment">     * 在<span class="hljs-doctag">@Bean</span>("user")， 如指定方法名，则使用定制的方法名</span><span class="hljs-comment">     * 在<span class="hljs-doctag">@Bean</span>中还有initMethod属性和destroyMethod属性，可以指定初始话方法和销毁方法</span><span class="hljs-comment">     */</span>     <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"user"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">user</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User();    &#125;</code></pre><h3 id="3-使用-Import注解"><a href="#3-使用-Import注解" class="headerlink" title="3. 使用@Import注解"></a>3. 使用@Import注解</h3><p> 该方法注入的Bean的id默认是组件的全类名 ，使用@Import就是将类注入到容器中，如果要注入的类没有被标注@Component也能被注入进来，一般注入的都是标注了@Configuration的配置类。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 该方式会将Bike类注入到容器中</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * */</span><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@Import</span>(&#123;Bike<span class="hljs-class">.<span class="hljs-keyword">class</span>&#125;)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">Config</span> </span>&#123; &#125; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bike</span> </span>&#123; &#125;</code></pre><h3 id="4-实现ImportSelector接口来向容器注入bean"><a href="#4-实现ImportSelector接口来向容器注入bean" class="headerlink" title="4. 实现ImportSelector接口来向容器注入bean"></a>4. 实现ImportSelector接口来向容器注入bean</h3><p><strong>注意：使用这种方式的话返回值不能为null，不然会出现空指针异常</strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">*使用<span class="hljs-doctag">@Import</span>注解，是将MyImportSelector类注入到IOC容器中，至于它是不是ImportSelector的实现类，</span><span class="hljs-comment">*这个<span class="hljs-doctag">@Import</span>注解是不进行判断的，在注入这个Bean后，有其他的组件会找到ImportSelector的实现类，并调</span><span class="hljs-comment">*用selectImports方法进行注册Bean</span><span class="hljs-comment">* */</span> <span class="hljs-meta">@Configuration</span><span class="hljs-meta">@Import</span>(&#123;MyImportSelector<span class="hljs-class">.<span class="hljs-keyword">class</span>&#125;)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">ImportConfig</span> </span>&#123; &#125; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyImportSelector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportSelector</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 返回值，就是到导入到容器中的组件全类名，返回值时一个字符串数组，可以导入多个bean</span><span class="hljs-comment">     * AnnotationMetadata:当前标注<span class="hljs-doctag">@Import</span>注解的类的所有注解信息</span><span class="hljs-comment">     * */</span>    <span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"com.harrison.User"</span>&#125;;    &#125;&#125;</code></pre><h3 id="5-实现ImportBeanDefinitionRegistrar接口来向容器注入Bean"><a href="#5-实现ImportBeanDefinitionRegistrar接口来向容器注入Bean" class="headerlink" title="5. 实现ImportBeanDefinitionRegistrar接口来向容器注入Bean"></a>5. 实现ImportBeanDefinitionRegistrar接口来向容器注入Bean</h3><p>这里的代码来自于DataSourceInitializedPublisher$Registrar类</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> ImportBeanDefinitionRegistrar&#125; to register the</span><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> DataSourceInitializedPublisher&#125; without causing early bean instantiation</span><span class="hljs-comment"> * issues.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Registrar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportBeanDefinitionRegistrar</span> </span>&#123;     <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String BEAN_NAME = <span class="hljs-string">"dataSourceInitializedPublisher"</span>;       <span class="hljs-comment">/**</span><span class="hljs-comment">       * AnnotationMetadata：当前类的注解信息</span><span class="hljs-comment">       * BeanDefinitionRegistry:BeanDefinition注册类；</span><span class="hljs-comment">       *      把所有需要添加到容器中的bean；调用</span><span class="hljs-comment">       *      BeanDefinitionRegistry.registerBeanDefinition手工注册进来</span><span class="hljs-comment">       */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata importingClassMetadata,</span></span><span class="hljs-function"><span class="hljs-params">                                        BeanDefinitionRegistry registry)</span> </span>&#123;        <span class="hljs-keyword">if</span> (!registry.containsBeanDefinition(BEAN_NAME)) &#123;            GenericBeanDefinition beanDefinition = <span class="hljs-keyword">new</span> GenericBeanDefinition();            beanDefinition.setBeanClass(DataSourceInitializedPublisher<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);            <span class="hljs-comment">// We don't need this one to be post processed otherwise it can cause a</span>            <span class="hljs-comment">// cascade of bean instantiation that we would rather avoid.</span>            beanDefinition.setSynthetic(<span class="hljs-keyword">true</span>);            registry.registerBeanDefinition(BEAN_NAME, beanDefinition);        &#125;    &#125; &#125;</code></pre><p>该方法可以有选择性的注入bean，传递的参数可以获取到IOC容器中关于bean的BeanDefinitionRegistry，使用这样方式比较灵活，在查看Spring源码时，大量使用了这种方式。</p><p>ImportBeanDefinitionRegistrar的实现类，必须是被@Import进行导入的，如@Import（Registrar .class）,如果不使用@Import注解导入Registrar类，而是使用一个@Component注解，将Registrar类通过扫描的方式放入到容器中，那么registerBeanDefinitions方法就不会被执行。</p><blockquote><p>@Import导入的原理：</p><p>处理这个@Import是在ConfigurationClassPostProcessor类中进行的，ConfigurationClassPostProcessor类会扫描出所有的对象，封装成beanDefinition对象，然后判断是否对象中是否加了@Import注解，加了的话判断是否为<strong>ImportBeanDefinitionRegistrar</strong>的实现类，如果是，则执行接口对象的方法（这只是见简单的说一下，其实步骤复杂的多，会有递归调用什么的，这里简单理解一下就行）<strong>。</strong></p></blockquote><h3 id="6-实现Factory-Bean接口向容器注入Bean"><a href="#6-实现Factory-Bean接口向容器注入Bean" class="headerlink" title="6. 实现Factory Bean接口向容器注入Bean"></a>6. 实现Factory Bean接口向容器注入Bean</h3><p><strong>使用Spring提供的 FactoryBean（工厂Bean），默认获取到的是工厂bean调用getObject创建的对象，要获取工厂Bean本身，我们需要给id前面加一个&amp;。</strong></p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryBeanConfig</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 在容器里面注入UserFactoryBean</span><span class="hljs-comment">     * 在获取userFactoryBean名称的Bean时，得到的是User类型的bean，如想要得到UserFactoryBean类型的bean，需要使用</span><span class="hljs-comment">     * AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(FactoryBeanConfig.class);</span><span class="hljs-comment">     * String[] beanDefinitionNames = context.getBeanDefinitionNames("&amp;userFactoryBean");  这种获取的是UserFactoryBean类型的bean</span><span class="hljs-comment">     * String[] beanDefinitionNames = context.getBeanDefinitionNames("userFactoryBean");  这种获取的是User类型的bean</span><span class="hljs-comment">     * */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserFactoryBean <span class="hljs-title">userFactoryBean</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserFactoryBean();    &#125;&#125; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserFactoryBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FactoryBean</span> </span>&#123;     <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User();    &#125;     <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;     <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType() &#123;        <span class="hljs-keyword">return</span> User<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FactoryBean</tag>
      
      <tag>IOC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BeanFactory和FactoryBean的区别</title>
    <link href="/2020/08/19/BeanFactory%20%E5%92%8C%20FactoryBean%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2020/08/19/BeanFactory%20%E5%92%8C%20FactoryBean%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>BeanFactory和FactoryBean的区别，欢迎交流，指证错误。</p><a id="more"></a><h3 id="0-区别"><a href="#0-区别" class="headerlink" title="0. 区别"></a><strong>0. 区别</strong></h3><p>BeanFactory是个Factory，也就是IOC容器或对象工厂；FactoryBean是个Bean。在Spring中，所有的Bean都是由BeanFactory(也就是IOC容器)来进行管理的。但对FactoryBean而言，这个Bean不是简单的Bean，而是一个能生产或者修饰对象生成的工厂Bean,它的实现与设计模式中的工厂模式和修饰器模式类似。</p><h3 id="1-BeanFactory"><a href="#1-BeanFactory" class="headerlink" title="1. BeanFactory"></a><strong>1. BeanFactory</strong></h3><p>BeanFactory定义了IOC容器的最基本形式，并提供了IOC容器应遵守的的最基本的接口，也就是Spring IOC所遵守的最底层和最基本的编程规范。在Spring代码中，BeanFactory只是个接口，并不是IOC容器的具体实现，但是Spring容器给出了很多种实现，如 DefaultListableBeanFactory、XmlBeanFactory、ApplicationContext等，都是附加了某种功能的实现。原始的BeanFactory无法支持spring的许多插件，如<strong>AOP功能</strong>、<strong>Web应用</strong>等。ApplicationContext接口,它由BeanFactory接口派生而来，包含BeanFactory的所有功能，通常建议使用 ApplicationContext。</p><p>ApplicationContext以一种更向面向框架的方式工作以及对上下文进行分层和实现继承，ApplicationContext包还提供了以下的功能： </p><ul><li>MessageSource, 提供国际化的消息访问 </li><li>资源访问，如URL和文件 </li><li>事件传播 </li><li>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层; </li></ul><p><strong>Java代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.springframework.beans.factory; <span class="hljs-keyword">import</span> org.springframework.beans.BeansException; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanFactory</span> </span>&#123; String FACTORY_BEAN_PREFIX = <span class="hljs-string">"&amp;"</span>; <span class="hljs-function">Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> BeansException</span>; &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(String name, Class&lt;T&gt; requiredType)</span> <span class="hljs-keyword">throws</span> BeansException</span>; &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType)</span> <span class="hljs-keyword">throws</span> BeansException</span>; <span class="hljs-function">Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name, Object... args)</span> <span class="hljs-keyword">throws</span> BeansException</span>; <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">ontainsBean</span><span class="hljs-params">(String name)</span></span>; <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>; <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isPrototype</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>; <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isTypeMatch</span><span class="hljs-params">(String name, Class&lt;?&gt; targetType)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>; Class&lt;?&gt; getType(String name) <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException; String[] getAliases(String name); &#125;</code></pre><blockquote><ul><li>boolean containsBean(String beanName) 判断工厂中是否包含给定名称的bean定义，若有则返回true</li><li>Object getBean(String) 返回给定名称注册的bean实例。根据bean的配置情况，如果是singleton模式将返回一个共享实例，否则将返回一个新建的实例，如果没有找到指定bean,该方法可能会抛出异常</li><li>Object getBean(String, Class) 返回以给定名称注册的bean实例，并转换为给定class类型</li><li>Class getType(String name) 返回给定名称的bean的Class,如果没有找到指定的bean实例，则排除NoSuchBeanDefinitionException异常</li><li>boolean isSingleton(String) 判断给定名称的bean定义是否为单例模式</li><li>String[] getAliases(String name) 返回给定bean名称的所有别名 </li></ul></blockquote><h3 id="2-FactoryBean"><a href="#2-FactoryBean" class="headerlink" title="2. FactoryBean"></a>2. FactoryBean</h3><p>一般情况下，Spring通过<strong>反射机制</strong>利用<bean>的class属性指定实现类实例化Bean，在某些情况下，实例化Bean过程比较复杂，如果按照传统的方式，则需要在xml的<bean>中提供大量的配置信息。配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。Spring为此提供了一个org.springframework.bean.factory.FactoryBean的工厂类接口，用户可以通过实现该接口定制实例化Bean的逻辑。<br>FactoryBean接口对于Spring框架来说占用重要的地位，Spring自身就提供了70多个FactoryBean的实现。它们隐藏了实例化一些复杂Bean的细节，给上层应用带来了便利。从Spring3.0开始，FactoryBean开始支持泛型，即接口声明改为FactoryBean<T>的形式</T></bean></bean></p><p><strong>Java代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.springframework.beans.factory;  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FactoryBean</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;      <span class="hljs-function">T <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;      Class&lt;?&gt; getObjectType();      <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">()</span></span>;  &#125;</code></pre><p>在该接口中还定义了以下3个方法：<br><code>TgetObject()</code>：返回由FactoryBean创建的Bean实例，如果isSingleton()返回true，则该实例会放到Spring容器中单实例缓存池中；<br><code>booleanisSingleton()</code>：返回由FactoryBean创建的Bean实例的作用域是singleton还是prototype；<br><code>Class&lt;T&gt;getObjectType()</code>：返回FactoryBean创建的Bean类型。<br>当配置文件中<bean>的class属性配置的实现类是FactoryBean时，通过getBean()方法返回的不是FactoryBean本身，而是FactoryBean#getObject()方法所返回的对象，相当于FactoryBean#getObject()代理了getBean()方法。<br>例：如果使用传统方式配置下面Car的<bean>时，Car的每个属性分别对应一个<property>元素标签，较为繁琐。</property></bean></bean></p><p><strong>Java代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.harrison.factorybean;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxSpeed;    <span class="hljs-keyword">private</span> String brand;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> price;    <span class="hljs-comment">//Getter and Setter methods</span>&#125;</code></pre><p>   如果用FactoryBean的方式实现就灵活点，下例通过逗号分割符的方式一次性的为Car的所有属性指定配置值：</p><p><strong>Java代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.harrison.factorybean;<span class="hljs-keyword">import</span> org.springframework.beans.factory.FactoryBean;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CarFactoryBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FactoryBean</span>&lt;<span class="hljs-title">Car</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> String carInfo;    <span class="hljs-function"><span class="hljs-keyword">public</span> Car <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        Car car = <span class="hljs-keyword">new</span> Car();        String[] infos = carInfo.split(<span class="hljs-string">","</span>);        car.setBrand(infos[<span class="hljs-number">0</span>]);        car.setMaxSpeed(Integer.valueOf(infos[<span class="hljs-number">1</span>]));        car.setPrice(Double.valueOf(infos[<span class="hljs-number">2</span>]));        <span class="hljs-keyword">return</span> car;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Class&lt;Car&gt; <span class="hljs-title">getObjectType</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> Car<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getCarInfo</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.carInfo;    &#125;    <span class="hljs-comment">// 接受逗号分割符设置属性信息  </span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCarInfo</span><span class="hljs-params">(String carInfo)</span> </span>&#123;        <span class="hljs-keyword">this</span>.carInfo = carInfo;    &#125;&#125;</code></pre><p>有了这个CarFactoryBean后，就可以在配置文件中使用下面这种自定义的配置方式配置CarBean了：<br><code>&lt;bean id=&quot;car&quot; class=&quot;com.harrison.factorybean.CarFactoryBean&quot; P:carInfo=&quot;法拉利,400,2000000&quot;/&gt;</code><br>当调用getBean(“car”)时，Spring通过反射机制发现CarFactoryBean实现了FactoryBean的接口，这时Spring容器就调用接口方法CarFactoryBean#getObject()方法返回。如果希望获取CarFactoryBean的实例，则需要在使用getBean(beanName)方法时在beanName前显示的加上”&amp;”前缀：如getBean(“&amp;car”);</p><h3 id="3-区别"><a href="#3-区别" class="headerlink" title="3.  区别"></a>3.  区别</h3><p>BeanFactory是个Factory，也就是IOC容器或对象工厂，FactoryBean是个Bean。在Spring中，所有的Bean都是由BeanFactory(也就是IOC容器)来进行管理的。但对FactoryBean而言，这个Bean不是简单的Bean，而是一个能生产或者修饰对象生成的工厂Bean,它的实现与设计模式中的工厂模式和修饰器模式类似。</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BeanFactory</tag>
      
      <tag>FactoryBean</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式文件系统FastDFS</title>
    <link href="/2020/08/16/FastDFS/"/>
    <url>/2020/08/16/FastDFS/</url>
    
    <content type="html"><![CDATA[<p>FastDFS知识小结，欢迎交流，指证错误。</p><a id="more"></a><h2 id="1-FastDFS介绍"><a href="#1-FastDFS介绍" class="headerlink" title="1. FastDFS介绍"></a>1. FastDFS介绍</h2><blockquote><p> FastDFS 是以C语言开发的一项开源轻量级分布式文件系统，他对文件进行管理，主要功能有：文件存储，文件同步，文件访问（文件上传/下载）,特别适合以文件为载体的在线服务，如图片网站，视频网站等</p><p>分布式文件系统：<br>基于客户端/服务器的文件存储系统<br>对等特性允许一些系统扮演客户端和服务器的双重角色，可供多个用户访问的服务器，比如，用户可以“发表”一个允许其他客户机访问的目录，一旦被访问，这个目录对客户机来说就像使用本地驱动器一样</p></blockquote><h4 id="1-1-FastDFS构成"><a href="#1-1-FastDFS构成" class="headerlink" title="1.1. FastDFS构成"></a>1.1. FastDFS构成</h4><blockquote><p> FastDFS由跟踪服务器(Tracker Server)、存储服务器(Storage Server)和客户端(Client)构成</p></blockquote><h5 id="1-1-1-Tracker-server-追踪服务器"><a href="#1-1-1-Tracker-server-追踪服务器" class="headerlink" title="1.1.1. Tracker server 追踪服务器"></a>1.1.1. Tracker server 追踪服务器</h5><p>追踪服务器负责接收客户端的请求，选择合适的组合storage server ，tracker server 与 storage server之间也会用心跳机制来检测对方是否活着。<br> Tracker需要管理的信息也都放在内存中，并且里面所有的Tracker都是对等的（每个节点地位相等），很容易扩展<br> 客户端访问集群的时候会随机分配一个Tracker来和客户端交互。</p><h5 id="1-1-2-Storage-server-储存服务器"><a href="#1-1-2-Storage-server-储存服务器" class="headerlink" title="1.1.2. Storage server 储存服务器"></a>1.1.2. Storage server 储存服务器</h5><p>实际存储数据，分成若干个组（group），实际traker就是管理的storage中的组，而组内机器中则存储数据，group可以隔离不同应用的数据，不同的应用的数据放在不同group里面，</p><ul><li>优点：<br> 海量的存储：主从型分布式存储，存储空间方便拓展,<br> FastDFS对文件内容做hash处理，避免出现重复文件<br> 然后FastDFS结合Nginx集成, 提供网站效率</li></ul><h5 id="1-1-3-客户端Client"><a href="#1-1-3-客户端Client" class="headerlink" title="1.1.3. 客户端Client"></a>1.1.3. 客户端Client</h5><p>  主要是上传下载数据的服务器，也就是我们自己的项目所部署在的服务器。每个客户端服务器都需要安装Nginx</p><p><img src="https://gitee.com/yuanlu_k/BlogImages/raw/master/FastDFS/FastDFS%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" srcset="/img/loading.gif" alt="FastDFS系统结构图"></p><center>FastDFS三方交互图</center><h2 id="2-上传下载操作"><a href="#2-上传下载操作" class="headerlink" title="2. 上传下载操作"></a>2. 上传下载操作</h2><h4 id="2-1-上传文件"><a href="#2-1-上传文件" class="headerlink" title="2.1. 上传文件"></a>2.1. 上传文件</h4><p>写操作的时候，storage会将他所挂载的所有数据存储目录的底下都创建2级子目录，每一级256个总共65536个，新写的文件会以hash的方式被路由到其中某个子目录下，然后将文件数据作为本地文件存储到该目录中。</p><p><img src="https://gitee.com/yuanlu_k/BlogImages/raw/master/FastDFS/FastDFS%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%B5%81%E7%A8%8B%E5%9B%BE.png" srcset="/img/loading.gif" alt="FastDFS文件上传流程图"></p><h4 id="2-2-下载文件"><a href="#2-2-下载文件" class="headerlink" title="2.2. 下载文件"></a>2.2. 下载文件</h4><p>当客户端向Tracker发起下载请求时，并不会直接下载，而是先查询storage server（检测同步状态），返回storage server的ip和端口，<br> 然后客户端会带着文件信息（组名，路径，文件名），去访问相关的storage，然后下载文件。</p><p><img src="https://gitee.com/yuanlu_k/BlogImages/raw/master/FastDFS/FastDFS%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%B5%81%E7%A8%8B%E5%9B%BE.png" srcset="/img/loading.gif" alt="FastDFS文件下载流程图"></p><h2 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h2><ol><li>首先下载fastdfs安装包和依赖包（<a href="https://sourceforge.net/projects/fastdfs/" target="_blank" rel="noopener">sourceforge-&gt;fastdfs</a>），</li></ol><p>然后解压至/usr/local/下,</p><pre><code class="hljs bash">tar -zxvf FastDFS_v6.06.tar.gz -C /usr/<span class="hljs-built_in">local</span></code></pre><p>再编译安装，</p><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/fastdfs_6.06   ./make.sh ./make.sh install  <span class="hljs-comment">#编译安装</span></code></pre><ol start="2"><li>配置tracker</li></ol><pre><code class="hljs bash">sudo cp /etc/fdfs/tracker.conf.sample /etc/fdfs/tracker.conf</code></pre><p>在/home/harrison/目录中创建目录 fastdfs/tracker</p><pre><code class="hljs bash">mkdir –p /home/harrison/fastdfs/tracker</code></pre><p>编辑/etc/fdfs/tracker.conf配置文件</p><pre><code class="hljs bash">sudo vim /etc/fdfs/tracker.conf</code></pre><p>修改 <code>base_path=/home/python/fastdfs/tracker</code></p><ol start="3"><li>配置storage</li></ol><pre><code class="hljs bash">sudo cp /etc/fdfs/storage.conf.sample /etc/fdfs/storage.conf</code></pre><p>在/home/harrison/fastdfs/ 目录中创建目录 storage，这个目录就是实际数据存储的位置</p><pre><code class="hljs bash">mkdir –p /home/harrison/fastdfs/storage</code></pre><ol start="4"><li>编辑/etc/fdfs/storage.conf配置文件</li></ol><pre><code class="hljs bash">sudo vim /etc/fdfs/storage.conf</code></pre><p>修改内容：</p><pre><code class="hljs bash">base_path=/home/harrison/fastdfs/storagestore_path0=/home/harrison/fastdfs/storagetracker_server=tracker所在机器的ip:22122</code></pre><ol start="5"><li>启动tracker和storage</li></ol><pre><code class="hljs bash">service fdfs_trackerd start <span class="hljs-comment"># 开启Tracker Server</span>service fdfs_storaged start <span class="hljs-comment"># 开启Storage Server</span></code></pre><p>至此，FastDFS服务端以安装完毕。</p><h2 id="4-利用FastDFS-Java客户端测试"><a href="#4-利用FastDFS-Java客户端测试" class="headerlink" title="4. 利用FastDFS Java客户端测试"></a>4. 利用FastDFS <a href="https://github.com/tobato/FastDFS_Client" target="_blank" rel="noopener">Java客户端</a>测试</h2><p>测试源代码在我的<a href="https://github.com/kangkanglang/FastDFS_Client_Test" target="_blank" rel="noopener">GitHub</a>上。</p><ol><li>根据<a href="https://github.com/tobato/FastDFS_Client" target="_blank" rel="noopener">FastDFS_Client的文档</a>，将FastDFS-Client客户端引入本地化项目的方式非常简单，在SpringBoot项目<code>/src/[com.xxx.主目录]/conf</code>当中配置</li></ol><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 导入FastDFS-Client组件</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> tobato</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@Import</span>(FdfsClientConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">// 解决<span class="hljs-title">jmx</span>重复注册<span class="hljs-title">bean</span>的问题</span><span class="hljs-class">@<span class="hljs-title">EnableMBeanExport</span>(<span class="hljs-title">registration</span> </span>= RegistrationPolicy.IGNORE_EXISTING)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComponetImport</span> </span>&#123;    <span class="hljs-comment">// 导入依赖组件</span>&#125;</code></pre><ol start="2"><li>在application.yml当中配置Fdfs相关参数</li></ol><pre><code class="hljs yaml"><span class="hljs-comment"># ===================================================================</span><span class="hljs-comment"># 分布式文件系统FDFS配置</span><span class="hljs-comment"># ===================================================================</span><span class="hljs-attr">fdfs:</span>  <span class="hljs-attr">so-timeout:</span> <span class="hljs-number">1501</span>  <span class="hljs-attr">connect-timeout:</span> <span class="hljs-number">601</span>   <span class="hljs-attr">thumb-image:</span>             <span class="hljs-comment">#缩略图生成参数</span>    <span class="hljs-attr">width:</span> <span class="hljs-number">150</span>    <span class="hljs-attr">height:</span> <span class="hljs-number">150</span>  <span class="hljs-attr">tracker-list:</span>            <span class="hljs-comment">#TrackerList参数,支持多个</span>    <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-string">.xxx.xxx:22122</span><span class="hljs-comment">#    - 192.168.1.106:22122</span></code></pre><ol start="3"><li>编写测试类(具体源码在<a href="https://github.com/kangkanglang/FastDFS_Client_Test" target="_blank" rel="noopener">这里</a>)</li></ol><pre><code class="hljs java"><span class="hljs-meta">@RunWith</span>(SpringRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">SpringBootTest</span></span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">FastDFSTest</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * test 1 -- 图片上传</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testUpload</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;        <span class="hljs-comment">//上传图片</span>        StorePath storePath = <span class="hljs-keyword">this</span>.storageClient.uploadFile(<span class="hljs-keyword">new</span> FileInputStream(file), file.length(), Variables.fileExtName, metaDataSet);        printlnPath(storePath);    &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">     * 下载文件</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">downLoadFile</span><span class="hljs-params">()</span> </span>&#123;        DownloadFileWriter callback = <span class="hljs-keyword">new</span> DownloadFileWriter(Variables.filename);        <span class="hljs-keyword">this</span>.storageClient.downloadFile(Variables.groupName, Variables.path, callback);    &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">     * 删除文件</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDel</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.storageClient.deleteFile(Variables.filePath);    &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">     * 查询文件</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testQuery</span><span class="hljs-params">()</span> </span>&#123;        FileInfo fileInfo = <span class="hljs-keyword">this</span>.storageClient.queryFileInfo(Variables.groupName, Variables.path);        System.out.println(<span class="hljs-string">"图片信息如下：\n"</span> + fileInfo.getCrc32() + <span class="hljs-string">"\n"</span> + <span class="hljs-keyword">new</span> Date(fileInfo.getCreateTime()) + <span class="hljs-string">"\n"</span> + fileInfo.getFileSize() + <span class="hljs-string">"\n"</span> + fileInfo.getSourceIpAddr());    &#125;    &#125;</code></pre><p>OK, 如果在测试中发现 “com.github.tobato.fastdfs.exception.FdfsConnectException: 无法获取服务端连接资源” 异常，可查看这些<a href="https://kangkanglang.github.io/2020/08/15/FastDFS%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/">解决方法</a>。</p>]]></content>
    
    
    <categories>
      
      <category>FastDFS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FastDFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot 、Mybatis 与 websocket 之间的一些问题</title>
    <link href="/2020/08/15/WebSocket%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98/"/>
    <url>/2020/08/15/WebSocket%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>SpringBoot 、Mybatis 与 websocket 之间的一些问题，欢迎交流，指证错误。</p><a id="more"></a><p>最近在做一个小项目，用到了SpringBoot 和 websocket，先大概讲一下所遇到的问题。</p><p>问题：</p><blockquote><p>前端JS通过websocket和和服务器中的WebSocketServlet 连接，在WebSocketServlet中注入HeatMapService，这时候出现第一个问题，<font color="red">发现注入的HeatMapService为null，也就是说这个时候Spring容器无法将HeatMapService注入</font>；当时没太在意，想着既然Spring无法注入，那就自己实例化 HeatMapService 就好了，然后就傻乎乎的自己实例化了HeatMapService，到这没啥大问题，至少代码跑起来了。下午准备把数据存到数据库时，出现了第二个问题，<font color="red">在HeatMapServiceImpl中想要注入HeatMapMapper时，发现此时注入的HeatMapMapper居然也为null</font>，自己的第一反应是Mybatis和SpringBoot整合时可能出问题了，检查MainApplication.java上有添加@MapperScanner，对应路径也没有写错，那这是为什么无法注入Mapper呢？</p></blockquote><p>服务端websocket中的<font color="red">部分错误代码</font>：</p><pre><code class="hljs java"><span class="hljs-meta">@ServerEndpoint</span>(value = <span class="hljs-string">"/websocket"</span>)<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSocketServlet</span> </span>&#123;        <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> HeatMapService heatMapService;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;    <span class="hljs-comment">//用来存放每个客户端对应的webSocketSet对象。</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> CopyOnWriteArraySet&lt;WebSocketServlet&gt; webSocketSet = <span class="hljs-keyword">new</span> CopyOnWriteArraySet&lt;WebSocketServlet&gt;();    <span class="hljs-keyword">private</span>  Session session=<span class="hljs-keyword">null</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@ClassName</span>: onOpen</span><span class="hljs-comment">     * <span class="hljs-doctag">@Description</span>: 开启连接的操作</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@OnOpen</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onOpen</span><span class="hljs-params">(Session session)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;       <span class="hljs-comment">//TODO</span>    &#125;&#125;</code></pre><p>先解决第二个问题：</p><p>经过几个小时zz般的排查，依旧没有想清SpringBoot 和 Mybatis整合到底哪出错了，于是准备把整个流程重新捋一遍，当走到WebSocketServlet 时，才发现是自己上午实例化的HeatMapService的问题。<font color="red">由于是自己的手动实例化的，因此实例化的heatMapService对象肯定是不在Spring容器中的，根据Spring的“依赖注入”，自然也无法将HeatMapMapper注入到Spring容器中</font>。知道问题所在，那就把HeatMapService通过Spring的方式注入进容器即可，问题二解决。</p><p>问题二解决了，自然问题一又回来了，为什么WebSocketServlet 中无法注入HeatMapService呢 ？<font color="red">原来WebSocket是多例的，而Spring管理的对象默认是单例的，即Spring默认只实例化一次HeatMapService，而WebSocketServlet 每新添加一个连接就会新增一个socket对象，自然无法将每一个socket对象中的HeatMapService进行实例化注入</font>。解决的办法就是将HeatMapService由成员变量，变成类变量即可，让所有的socket对象共享同一个HeatMapService。</p><p>问题解决后的WebSocketServlet 代码：</p><pre><code class="hljs java"><span class="hljs-meta">@ServerEndpoint</span>(value = <span class="hljs-string">"/websocket"</span>)<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSocketServlet</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> HeatMapService heatMapService;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHeatMapService</span><span class="hljs-params">(HeatMapService heatMapService)</span></span>&#123;        WebSocketServlet.heatMapService = heatMapService;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;    <span class="hljs-comment">//用来存放每个客户端对应的webSocketSet对象。</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> CopyOnWriteArraySet&lt;WebSocketServlet&gt; webSocketSet = <span class="hljs-keyword">new</span> CopyOnWriteArraySet&lt;WebSocketServlet&gt;();    <span class="hljs-keyword">private</span>  Session session=<span class="hljs-keyword">null</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@ClassName</span>: onOpen</span><span class="hljs-comment">     * <span class="hljs-doctag">@Description</span>: 开启连接的操作</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@OnOpen</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onOpen</span><span class="hljs-params">(Session session)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;      <span class="hljs-comment">//TODO</span>    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@ClassName</span>: onClose</span><span class="hljs-comment">     * <span class="hljs-doctag">@Description</span>: 连接关闭的操作</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@OnClose</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClose</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"connection is closed..."</span>);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@ClassName</span>: onMessage</span><span class="hljs-comment">     * <span class="hljs-doctag">@Description</span>: 从前端接收消息</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@OnMessage</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(String message)</span> </span>&#123;        <span class="hljs-comment">//TODO</span>    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@ClassName</span>: OnError</span><span class="hljs-comment">     * <span class="hljs-doctag">@Description</span>: 出错的操作</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@OnError</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable error)</span></span>&#123;        System.out.println(error);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 将消息发送给前端</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(SensorVO sensor)</span></span>&#123;        <span class="hljs-comment">//TODO</span>    &#125;&#125;</code></pre><p>参考 ：<a href="https://blog.csdn.net/m0_37202351/article/details/86255132" target="_blank" rel="noopener">spring springboot websocket 不能注入( @Autowired ) service bean 报 null 错误</a></p><p>还是自己code太少了，项目经验太少，这样的错误，希望自己以后不会再犯~</p>]]></content>
    
    
    <categories>
      
      <category>Problems</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Problems</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FastDFS 无法获取服务端连接资源问题</title>
    <link href="/2020/08/15/FastDFS%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2020/08/15/FastDFS%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>“com.github.tobato.fastdfs.exception.FdfsConnectException: 无法获取服务端连接资源：can’t create connection to/ip:22122” 的解决方案。</p><a id="more"></a><p>之前在Github上clone了一个<a href="https://github.com/lenve/vhr" target="_blank" rel="noopener">微人事项目</a>，然后在本地虚拟机上安装了FastDFS，之前是测试通过了。但是今天再次使用FastDFS时，却报如下错误：<br>自己在本地搭建FastDFS项目，项目源码在<a href="https://github.com/kangkanglang/JavaLearning/tree/master/FastDFSTest" target="_blank" rel="noopener">我的GitHub</a>上。</p><blockquote><p><font color="red">com.github.tobato.fastdfs.exception.FdfsConnectException: 无法获取服务端连接资源：can’t create connection to/192.168.xxx.xxx:22122</font></p></blockquote><p>现在提供以下3种解决办法：</p><h4 id="1-检查项目application-yml配置文件中的IP地址是否正确（虚拟机的IP地址可能会发生改变）。"><a href="#1-检查项目application-yml配置文件中的IP地址是否正确（虚拟机的IP地址可能会发生改变）。" class="headerlink" title="1. 检查项目application.yml配置文件中的IP地址是否正确（虚拟机的IP地址可能会发生改变）。"></a>1. 检查项目application.yml配置文件中的IP地址是否正确（虚拟机的IP地址可能会发生改变）。</h4><p>application.yml中关于FastDFS的配置：</p><pre><code class="hljs yml"><span class="hljs-comment"># ===================================================================</span><span class="hljs-comment"># 分布式文件系统FDFS配置</span><span class="hljs-comment"># ===================================================================</span><span class="hljs-attr">fdfs:</span>  <span class="hljs-attr">so-timeout:</span> <span class="hljs-number">6000</span>  <span class="hljs-attr">connect-timeout:</span> <span class="hljs-number">6000</span>  <span class="hljs-attr">thumb-image:</span>             <span class="hljs-comment">#缩略图生成参数</span>    <span class="hljs-attr">width:</span> <span class="hljs-number">150</span>    <span class="hljs-attr">height:</span> <span class="hljs-number">150</span>  <span class="hljs-attr">tracker-list:</span>            <span class="hljs-comment">#TrackerList参数,支持多个</span>    <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-string">.xxx.xxx:22122</span></code></pre><p>本人虚拟机的IP地址就发生了改变，遂要修改项目application.yml中的IP配置，同时也要修改虚拟机中关于storage的配置文件。<br>即将 <code>/etc/fdfs/storage.conf</code> 配置文件中的IP修改成当前IP地址。</p><pre><code class="hljs bash">tracker_server=192.168.xxx.xxx:22122</code></pre><p>经过上述2步修改后，将Tracker Server和Storage Server分别进行重启，即</p><pre><code class="hljs bash">service fdfs_trackerd stop <span class="hljs-comment"># 关闭Tracker Server</span>service fdfs_trackerd start <span class="hljs-comment"># 开启Tracker Server</span></code></pre><pre><code class="hljs bash">service fdfs_storaged stop <span class="hljs-comment"># 关闭Storage Server</span>service fdfs_storaged start <span class="hljs-comment"># 开启Storage Server</span></code></pre><h4 id="2-Tracker-Server和Storage-Server未启动"><a href="#2-Tracker-Server和Storage-Server未启动" class="headerlink" title="2. Tracker Server和Storage Server未启动"></a>2. Tracker Server和Storage Server未启动</h4><p>可通过以下命令检测两个Server是否启动</p><pre><code class="hljs bash">netstat -anp | grep 22122 <span class="hljs-comment"># 检测Tracker Server是否启动</span>netstat -anp | grep 3000 <span class="hljs-comment"># 检测Tracker Server是否启动</span></code></pre><p>若未启动，则分别执行以上两个命令后，无任何输出；若是启动了，则输出如下内容：</p><pre><code class="hljs bash"><span class="hljs-comment"># Tracker Server 启动</span>tcp   0   0.0.0.0:22122     0.0.0.0:*     LISTEN    1972/fdfs_trackerd<span class="hljs-comment"># Tracker Server 启动</span>tcp   0   0.0.0.0:23000     0.0.0.0:*     LISTEN    2056/fdfs_storaged</code></pre><p>若是未启动，则分将两个Server启动即可：</p><pre><code class="hljs bash">service fdfs_trackerd start <span class="hljs-comment"># 开启Tracker Server</span>service fdfs_storaged start <span class="hljs-comment"># 开启Storage Server</span></code></pre><h3 id="3-尝试关闭虚拟机的防火墙"><a href="#3-尝试关闭虚拟机的防火墙" class="headerlink" title="3. 尝试关闭虚拟机的防火墙"></a>3. 尝试关闭虚拟机的防火墙</h3><p>不同系统关闭防火墙的方式各不一样，可自行寻找方法。</p>]]></content>
    
    
    <categories>
      
      <category>Problems</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FastDFS</tag>
      
      <tag>Problems</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTPS知识积累</title>
    <link href="/2020/08/14/HTTPS/"/>
    <url>/2020/08/14/HTTPS/</url>
    
    <content type="html"><![CDATA[<p>HTTPS相关知识小结，欢迎交流，指证错误。</p><a id="more"></a><h2 id="1-HTTP协议中所存在的问题"><a href="#1-HTTP协议中所存在的问题" class="headerlink" title="1. HTTP协议中所存在的问题"></a>1. HTTP协议中所存在的问题</h2><blockquote><ul><li>数据是明文传输，容易被窃听截取</li><li>数据的完整性未校验，容易被篡改</li><li>没有验证对方身份，存在冒充危险</li></ul></blockquote><h2 id="2-HTTPS协议"><a href="#2-HTTPS协议" class="headerlink" title="2. HTTPS协议"></a>2. HTTPS协议</h2><p>为了解决上述HTTP存在的问题，就用到了HTTPS。</p><blockquote><p>HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：可以理解为HTTP+SSL/TLS， 即 HTTP 下加入 SSL（Secure Socket Layer，安全套接字层）层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL，用于安全的 HTTP 数据传输。</p></blockquote><p>如下图所示： HTTPS 相比 HTTP 多了一层 SSL/TLS</p><p><img src="https://gitee.com/yuanlu_k/BlogImages/raw/master/Https/https_ssl.png" srcset="/img/loading.gif" alt="HTTPS SSL/TLS"></p><h3 id="2-1-加密算法"><a href="#2-1-加密算法" class="headerlink" title="2.1. 加密算法"></a>2.1. 加密算法</h3><ul><li><p>对称加密</p><ul><li>即加密的密钥和解密的密钥相同</li><li>优点：计算量小、加密速度快、加密效率高。</li><li>缺点:（1）交易双方都使用同样密钥，安全性得不到保证；（2）每次使用对称加密算法时，都需要使用其他人不知道的惟一密钥，这会使得发收信息双方所拥有的钥匙数量呈几何级数增长，密钥管理成为负担。</li></ul></li><li><p>非对称加密</p><ul><li>非对称加密将密钥分为公钥和私钥,公钥可以公开,私钥需要保密。</li><li>使用公钥对数据进行加密，可以用私钥解密得到数据；也可以使用私钥对数据进行加密，公钥解密得到数据。</li><li>但一般使用公钥加密，私钥解密。</li><li>优点：非对称加密相比对称加密更加安全</li><li>缺点：（1）CPU计算资源消耗非常大；（2）非对称加密算法对加密内容的长度有限制，不能超过公钥长度。比如现在常用的公钥长度是2048位，意味着待加密内容不能超过256个字节。</li></ul></li></ul><h3 id="2-2-建立连接"><a href="#2-2-建立连接" class="headerlink" title="2.2. 建立连接"></a>2.2. 建立连接</h3><ul><li>HTTP和HTTPS<strong><em>都需要在建立连接的基础上来进行数据传输</em></strong>,是基本操作</li><li>当客户在浏览器中输入网址的并且按下回车,浏览器会在浏览器DNS缓存,本地DNS缓存,和Hosts中寻找对应的记录,如果没有获取到则会请求DNS服务来获取对应的IP</li><li>当获取到IP后,TCP连接会进行三次握手建立连接</li></ul><h3 id="2-3-TCP的三次握手和四次挥手"><a href="#2-3-TCP的三次握手和四次挥手" class="headerlink" title="2.3. TCP的三次握手和四次挥手"></a>2.3. TCP的三次握手和四次挥手<a href="TCP和UDP详解"></a></h3><p>过程简图如下所示：</p><p><img src="https://gitee.com/yuanlu_k/BlogImages/raw/master/Https/TCP%E8%BF%9E%E6%8E%A5.png" srcset="/img/loading.gif" alt="三次握手和四次挥手"></p><blockquote><p><strong><em>三次握手（建立连接）</em></strong></p><ul><li>第一次：建立连接时，客户端发送SYN包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；</li><li>第二次：服务器收到SYN包，向客户端返回ACK（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RCVD状态；</li><li>第三次：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</li><li>完成三次握手，客户端与服务器开始传送数据，也就是ESTABLISHED状态。</li><li>三次握手保证了不会建立无效的连接，从而浪费资源。</li></ul></blockquote><blockquote><p><strong><em>四次挥手（释放连接）</em></strong></p><ul><li>第一次：TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送。</li><li>第二次：服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。</li><li>第三次：服务器关闭客户端的连接，发送一个FIN给客户端。</li><li>第四次：客户端发回ACK报文确认，并将确认序号设置为收到序号加1。</li></ul></blockquote><h3 id="2-4-HTTPS请求"><a href="#2-4-HTTPS请求" class="headerlink" title="2.4. HTTPS请求"></a>2.4. HTTPS请求</h3><p>在TCP连接建立之后，HTTPS请求过程如下图所示：</p><p><img src="https://gitee.com/yuanlu_k/BlogImages/raw/master/Https/HTTPS.png" srcset="/img/loading.gif" alt="HTTPS请求"></p><blockquote><p>①发送客户端支持的加密协议及版本，非对称加密算法，随机数1</p><p>②服务端筛选加密协议，对称算法，随机数2，证书（License）</p><p>③客户端先从 CA 验证该证书的合法性，验证通过后取出证书中的服务端公钥</p><p>④生成随机数3，再用服务端公钥非对称加密随机数3，生成 PreMaster Key</p><p>⑤服务端依据私钥解密PreMaster Key，得出随机数3</p><p>⑥至此，客户端和服务端都有了三个随机数，再依据相同的算法生成对称加密的密钥</p><p>⑦客户端和服务端开始使用对称加密后的密文进行通信。</p></blockquote><h3 id="2-5-HTTPS的缺点"><a href="#2-5-HTTPS的缺点" class="headerlink" title="2.5. HTTPS的缺点"></a>2.5. HTTPS的缺点</h3><ul><li>HTTPS协议多次握手，导致页面的加载时间延长近50%；</li><li>HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗；</li><li>申请SSL证书需要钱，功能越强大的证书费用越高。</li><li>SSL涉及到的安全算法会消耗 CPU 资源，对服务器资源消耗较大。</li></ul><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><ul><li>HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的；HTTPS使用了SSL/TLS协议进行了加密处理。</li><li>HTTPS和HTTP使用连接方式不同，默认端口也不一样，HTTP是80，HTTPS是443。</li><li>HTTPS中在请求过程中使用非对称加密技术，而在通信过程中使用的是对称加密技术。</li><li>HTTPS需要非对称加密 、 对称加密 和 CA 共同实现。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTPS</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LRU算法的实现</title>
    <link href="/2020/08/11/LRU/"/>
    <url>/2020/08/11/LRU/</url>
    
    <content type="html"><![CDATA[<p>LRU算法的实现，欢迎交流，指证错误。</p><a id="more"></a><p>LRU是Least Recently Used的缩写，即最近最少使用，常用于页面置换算法，是为虚拟页式存储管理服务的。</p><blockquote><p>LRU 算法的<strong><em>设计原则</em></strong>是：如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。也就是说，当限定的空间已存满数据时，应当把最久没有被访问到的数据淘汰。</p></blockquote><h3 id="实现方案："><a href="#实现方案：" class="headerlink" title="实现方案："></a>实现方案：</h3><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Deque;<span class="hljs-keyword">import</span> java.util.HashMap;<span class="hljs-keyword">import</span> java.util.LinkedList;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-comment">/**</span><span class="hljs-comment"> * LRU 手动实现</span><span class="hljs-comment"> * LRU 每次淘汰最近最少使用的缓存value</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 思路：</span><span class="hljs-comment"> * 1、用HashMap作为缓存，实现添加缓存值和更新值</span><span class="hljs-comment"> * 2、通过一个双向链表记录缓存值的使用记录， 最近有使用的放入表头，最近最少使用的放在表尾</span><span class="hljs-comment"> * 3、HashMap中 key 即为搜索查询使用的 key ； value 是双向链表的结点 node</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Deque&lt;Node&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;Node&gt;();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span></span>&#123;        <span class="hljs-keyword">int</span> key;        <span class="hljs-keyword">int</span> value;        Node pre;        Node next;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">()</span></span>&#123;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span></span>&#123;            <span class="hljs-keyword">this</span>.key = key;            <span class="hljs-keyword">this</span>.value = value;        &#125;    &#125;    <span class="hljs-keyword">private</span> Map&lt;Integer, Node&gt; cache = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;    <span class="hljs-keyword">private</span> Node head, tail;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span></span>&#123;        <span class="hljs-keyword">this</span>.capacity = capacity;        <span class="hljs-keyword">this</span>.count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">this</span>.head = <span class="hljs-keyword">new</span> Node();        <span class="hljs-keyword">this</span>.tail = <span class="hljs-keyword">new</span> Node();        head.pre = <span class="hljs-keyword">null</span>;        head.next = tail;        tail.pre = head;        tail.next = <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 从缓存中取值</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 取值的key</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 若key所对应的值存在则返回，否则返回-1</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span></span>&#123;        Node node = cache.get(key);        <span class="hljs-keyword">if</span>(node != <span class="hljs-keyword">null</span>)&#123;            moveToHead(node);            <span class="hljs-keyword">return</span> node.value;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 往缓存中添加（更新）值</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 值对的key</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 缓存值</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span></span>&#123;        Node node = cache.get(key);        <span class="hljs-comment">// 未在缓存中，添加至缓存</span>        <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>)&#123;            node = <span class="hljs-keyword">new</span> Node(key, value);            cache.put(key, node);            addNode(node);            ++count;            <span class="hljs-keyword">if</span>(count &gt; capacity)&#123; <span class="hljs-comment">//超出容量</span>                popTail();                --count;            &#125;        &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 在缓存中， 更新缓存值</span>            node.value = value;            moveToHead(node);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 将链表中最后一个节点移除。同时也从缓存中移除</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">popTail</span><span class="hljs-params">()</span> </span>&#123;        Node node = tail.pre;        removeNode(node);        cache.remove(node.key);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 将节点移动至链表的头部，表示该节点刚添加 或 刚更新 。</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> node 节点</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">moveToHead</span><span class="hljs-params">(Node node)</span> </span>&#123;        removeNode(node);        addNode(node);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 添加节点</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> node 节点</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNode</span><span class="hljs-params">(Node node)</span> </span>&#123;        node.pre = head;        node.next = head.next;        head.next = node;        node.next.pre = node;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 移除指定节点</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> node 节点</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeNode</span><span class="hljs-params">(Node node)</span> </span>&#123;        node.pre.next = node.next;        node.next.pre = node.pre;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LRU</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 索引（一）B-/+树</title>
    <link href="/2020/08/07/MySQL%E7%B4%A2%E5%BC%95B+%E6%A0%91/"/>
    <url>/2020/08/07/MySQL%E7%B4%A2%E5%BC%95B+%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>MySQL索引相关知识小结，欢迎交流，指证错误。</p><a id="more"></a><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>MyISAM和InnoDB是MySQL最常用的两个存储引擎，本文将进行详尽的介绍和对比。</p><p>本文会图解两种引擎的索引结构区别，然后讲解索引的原理，理解本文内容，就能够理解索引优化的各种原则的背后原因。</p><blockquote><p>B-树、B树和B-tree是同一个数据结构。</p><p>MyISAM和InnoDB的索引均采用B+树数据结构，所以接下来先介绍一下B树与B+树。</p></blockquote><h2 id="1-B树和B-树"><a href="#1-B树和B-树" class="headerlink" title="1. B树和B+树"></a>1. B树和B+树</h2><h3 id="1-1-B树"><a href="#1-1-B树" class="headerlink" title="1.1. B树"></a>1.1. B树</h3><blockquote><p><strong><em>B树是一种多路搜索树。</em></strong></p><ul><li>定义任意非叶子结点最多只有M个儿子，且M&gt;2。</li><li>根结点的儿子数为[2, M]。</li><li>除根结点以外的非叶子结点的儿子数为[M/2, M]。</li><li>每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）。</li><li>非叶子结点的关键字个数=指向儿子的指针个数-1。</li><li>非叶子结点的关键字：K[1], K[2], …, K[M-1]，且K[i] &lt;= K[i+1]。</li><li>非叶子结点的指针：P[1], P[2], …,P[M]（其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树）。</li><li>所有叶子结点位于同一层。</li></ul></blockquote><p>下图是一个M=4阶的B树。</p><p><img src="https://gitee.com/yuanlu_k/BlogImages/raw/master/MySQL%E7%B4%A2%E5%BC%95/B%E6%A0%91.jpg" srcset="/img/loading.gif" alt="B树"><br>B树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的是叶子结点。</p><blockquote><p><strong><em>查找文件29的过程：</em></strong></p><ul><li>根据根结点指针找到文件目录的根磁盘块1，将其中的信息导入内存。（磁盘IO操作1次）</li><li>此时内存中有两个文件名17，35和三个存储其他磁盘页面地址的数据。根据算法我们发现17&lt;29&lt;35，因此我们找到指针p2。</li><li>根据p2指针，我们定位到磁盘块3，并将其中的信息导入内存。（磁盘IO操作2次）</li><li>此时内存中有两个文件名26，30和三个存储其他磁盘页面地址的数据。根据算法我们发现26&lt;29&lt;30，因此我们找到指针p2。</li><li>根据p2指针，我们定位到磁盘块8，并将其中的信息导入内存。（磁盘IO操作3次）</li><li>此时内存中有两个文件名28，29。根据算法我们查找到文件29，并定位了该文件内存的磁盘地址。</li></ul></blockquote><blockquote><p><strong><em>B树的特性：</em></strong></p><ul><li>关键字分布在整颗树的所有节点。</li><li>任何一个关键字出现且只出现在一个结点中。</li><li>搜索有可能在非叶子结点结束。</li><li>其搜索性能等价于在关键字全集内做一次二分查找。</li></ul></blockquote><h3 id="1-2-B-树"><a href="#1-2-B-树" class="headerlink" title="1.2. B+树"></a>1.2. B+树</h3><p>下图是一个M=3阶的B+树。</p><p><img src="https://gitee.com/yuanlu_k/BlogImages/raw/master/MySQL%E7%B4%A2%E5%BC%95/B+%E6%A0%91.jpg" srcset="/img/loading.gif" alt="B+树"></p><p>B+树是B树的一种变形树，总结起来，数据库索引的B+树与B树的差异在于：</p><ul><li>非叶子结点的子树指针与关键字个数相同。</li><li>非叶子结点的子树指针P[i]，指向关键字值属于[K[i],K[i+1])的子树（注意，区间是前闭后开）。</li><li>为所有叶子结点增加一个链指针。</li><li>所有关键字都在叶子结点出现。</li></ul><blockquote><p><strong><em>B+树的特性：</em></strong></p><ul><li>所有关键字都出现在叶子结点的链表中，且链表中的关键字是有序的。</li><li>搜索只在叶子结点命中。</li><li>非叶子结点相当于是叶子结点的索引，叶子结点是存储关键字数据的数据层。</li></ul></blockquote><h3 id="1-3-B-树做索引的原因"><a href="#1-3-B-树做索引的原因" class="headerlink" title="1.3. B-/+树做索引的原因"></a>1.3. B-/+树做索引的原因</h3><p>解释这个问题之前，需要了解一些基础知识。</p><p><strong><em>局部性原理与磁盘预读</em></strong><br>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：</p><blockquote><p>当一个数据被用到时，其附近的数据也通常会马上被使用——程序运行期间所需要的数据通常比较集中。</p></blockquote><p>由于磁盘<strong><em>顺序读取</em></strong>的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p><p>预读的长度一般为页的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p><p><strong><em>B-/+树做索引的原因分析</em></strong><br>一般来说，磁盘I/O次数可以用于评价索引结构的优劣。在B-Tree中查找，可知检索一次最多需要访问h个节点（上文举例查找文件29的过程）。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。</p><p>为了达到这个目的，在实际实现中，B树还使用如下技巧：</p><ul><li>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个节点只需一次I/O。</li><li>B树中一次检索最多需要h-1次I/O（根节点常驻内存）。一般实际应用中，出度d（树的分叉数）是非常大的数字，通常超过100；h非常小，通常不超过3。</li></ul><p>综上所述，用B树作为索引结构效率是非常高的。</p><p><strong><em>红黑树或者平衡二叉树的其他树结构</em></strong></p><ul><li>h明显要深的多，执行效率低。</li><li>逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，</li><li>每个节点存储的数据量太小了，对磁盘空间造成浪费，带来频繁的IO操作。</li></ul><p>所以其他树结构的效率明显比B树差很多。</p><blockquote><p><strong><em>相对B树，B+树做索引的优势</em></strong></p><ul><li>B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。</li><li>B+树的查询效率更加稳定：由于所有数据都存于叶子节点。所有关键字查询的路径长度相同，每一个数据的查询效率相当。</li><li>B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。</li></ul></blockquote><p>笔者认为第三条原因才是MySQL使用B+树而不是B树做索引的主要原因，毕竟MongoDB的索引是B树，所以两种数据结构并没有绝对的好坏，要看实际的业务需求。</p><p>文章源于：<a href="https://zhuanlan.zhihu.com/p/88866208" target="_blank" rel="noopener">一文彻底搞懂MySQL索引</a></p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>B-/+树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式 -- 代理模式</title>
    <link href="/2020/08/05/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/08/05/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>设计模式之代理模式，代理模式又分为静态代理和动态代理。</p><a id="more"></a><h2 id="1-代理模式UML示意图"><a href="#1-代理模式UML示意图" class="headerlink" title="1. 代理模式UML示意图"></a>1. 代理模式UML示意图</h2><p><img src="https://gitee.com/yuanlu_k/BlogImages/raw/master/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/proxyUML.jpg" srcset="/img/loading.gif" alt="代理模式"></p><blockquote><p>需要注意的有下面几点：</p><ol><li>用户(Client)只关心接口功能，而不在乎谁提供了功能。上图中接口是 Subject。</li><li>接口真正实现者是上图的 RealSubject，但是它不与用户直接接触，而是通过代理。</li><li>代理就是上图中的 Proxy，由于它实现了 Subject 接口，所以它能够直接与用户接触。</li><li>用户调用 Proxy 的时候，Proxy 内部调用了 RealSubject。所以，Proxy 是中介者，它可以增强 RealSubject 操作。</li></ol></blockquote><h2 id="2-静态代理"><a href="#2-静态代理" class="headerlink" title="2. 静态代理"></a>2. 静态代理</h2><p>静态代理在使用时,需要定义接口或者父类，<strong>被代理对象与代理对象一起实现相同的接口或者是继承相同父类</strong>。在<u>代理对象</u>中对<u>被代理对象</u>进行增强。</p><p>假设这样一个场景：有一个蛋糕店，它们卖的蛋糕都是用蛋糕机做的，而且不同种类的蛋糕由不同的蛋糕机来做，这样就有：水果蛋糕机、巧克力蛋糕机等。它们卖的面包片也是用面包机做的，同样不同种类的面包片也是由不同的面包机来做，这样就有：葡萄干面包机、红豆面包机等。这个场景用 Java 语言描述就是下面这样：</p><pre><code class="hljs java"><span class="hljs-comment">//做蛋糕的机器</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CakeMachine</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">makeCake</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//专门做水果蛋糕的机器</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FruitCakeMachine</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CakeMachine</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeCake</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"Making a fruit cake..."</span>);    &#125;&#125;<span class="hljs-comment">//专门做巧克力蛋糕的机器</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChocolateCakeMachine</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CakeMachine</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeCake</span><span class="hljs-params">()</span> </span>&#123;        System.out.printf(<span class="hljs-string">"making a Chocolate Cake..."</span>);    &#125;&#125;<span class="hljs-comment">//做面包的机器</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BreadMachine</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">makeBread</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">//专门做红豆面包的机器</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedBeanBreadMachine</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BreadMachine</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeBread</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"making red bean bread...."</span>);    &#125;&#125;<span class="hljs-comment">//专门做葡萄干面包的机器</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CurrantBreadMachine</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BreadMachine</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeBread</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"making currant bread..."</span>);    &#125;&#125;<span class="hljs-comment">//蛋糕店</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CakeShop</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">new</span> FruitCakeMachine().makeCake();        <span class="hljs-keyword">new</span> ChocolateCakeMachine().makeCake();        <span class="hljs-keyword">new</span> RedBeanBreadMachine().makeBread();        <span class="hljs-keyword">new</span> CurrantBreadMachine().makeBread();    &#125;&#125;</code></pre><p>上面的代码抽象出了一个 CakeMachine 接口和 BreadMachine 接口，有各种蛋糕机（FruitCakeMachine、ChocolateCakeMachine 等）实现了 CakeMachine 接口，有各种面包机（RedBeanBreadMachine、CurrantBreadMachine 等）实现了 BreadMachine 接口，最后蛋糕店（CakeShop）直接利用这些蛋糕机做蛋糕。</p><p>这样的一个例子真实地描述了实际生活中的场景。但生活中的场景往往是复杂多变的，假设这个时候来了一个顾客，他想要一个水果蛋糕，但他特别喜欢杏仁，希望在水果蛋糕上加上一层杏仁。这时候我们应该怎么做呢？</p><p>因为我们的蛋糕机只能做水果蛋糕（程序设定好了），没办法做杏仁水果蛋糕。最简单的办法是直接修改水果蛋糕机的程序，做一台能做杏仁水果蛋糕的蛋糕机。这种方式对应的代码修改也很简单，直接在原来的代码上进行修改，生成一台专门做杏仁水果蛋糕的机器就好了，修改后的 FruitCakeMachien 类应该是这样子：</p><pre><code class="hljs java"><span class="hljs-comment">//专门做水果蛋糕的机器，并且加上一层杏仁</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FruitCakeMachine</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CakeMachine</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeCake</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"making a Fruit Cake..."</span>);        System.out.println(<span class="hljs-string">"adding apricot..."</span>);    &#125;&#125;</code></pre><p>虽然上面这种方式实现了我们的业务需求。但是仔细想一想，在现实生活中如果我们遇到这样的一个需求，我们不可能因为一个顾客的特殊需求就去修改一台蛋糕机的硬件程序，这样成本太高！而且从代码实现角度上来说，<strong>这种方式从代码上不是很优雅，修改了原来的代码</strong>。根据代码圈中<strong>「对修改封闭、对扩展开放」</strong>的思想，我们在尝试满足新的业务需求的时候应该尽量少修改原来的代码，而是在原来的代码上进行拓展。</p><p>那我们究竟应该怎么做更加合适一些呢？我们肯定是直接用水果蛋糕机做一个蛋糕，然后再人工撒上一层杏仁啦。我们需要做的，其实就是设计一个杏仁代理类（ApricotCakeProxy），这个代理类就完成撒杏仁这个动作，之后让蛋糕店直接调用即可代理类去实现即可。</p><pre><code class="hljs java"><span class="hljs-comment">//杏仁蛋糕代理</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApricotCakeProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CakeMachine</span></span>&#123;    <span class="hljs-keyword">private</span> CakeMachine cakeMachine;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ApricotCakeProxy</span><span class="hljs-params">(CakeMachine cakeMachine)</span> </span>&#123;        <span class="hljs-keyword">this</span>.cakeMachine = cakeMachine;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeCake</span><span class="hljs-params">()</span> </span>&#123;        cakeMachine.makeCake();        System.out.println(<span class="hljs-string">"adding apricot..."</span>);    &#125;&#125;<span class="hljs-comment">//蛋糕店</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CakeShop</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//可以给各种各样的蛋糕加上杏仁</span>        FruitCakeMachine fruitCakeMachine = <span class="hljs-keyword">new</span> FruitCakeMachine();        ApricotCakeProxy apricotProxy = <span class="hljs-keyword">new</span> ApricotCakeProxy(fruitCakeMachine);        apricotProxy.makeCake();        apricotProxy = <span class="hljs-keyword">new</span> ApricotCakeProxy(<span class="hljs-keyword">new</span> ChocolateCakeMachine());        apricotProxy.makeCake();    &#125;&#125;</code></pre><p>这其实就对应了即使模式中的<strong>代理模式</strong>，虽然调用的是 ApricotCakeProxy 类的方法，但实际上真正做蛋糕的是 FruitCakeMachine 类。ApricotCakeProxy 类只是在 FruitCakeMachine 做出蛋糕后，撒上一层杏仁而已。而且通过代理，我们不仅可以给水果蛋糕撒上一层杏仁，还可以给巧克力蛋糕、五仁蛋糕等撒上一层杏仁。只要它是蛋糕（实现了 CakeMachine 接口），那么我们就可以给这个蛋糕撒上杏仁。</p><p>通过代理实现这样的业务场景，这样我们就不需要在原来的类上进行修改，从而使得代码更加优雅，拓展性更强。如果下次客人喜欢葡萄干水果蛋糕了了，那可以再写一个 CurrantCakeProxy 类来撒上一层葡萄干，原来的代码也不会被修改。上面说的这种业务场景就是代理模式的实际应用，准确地说这种是<strong>静态代理。</strong></p><p>小结：<strong>静态代理模式可以在不修改被代理对象的基础上，通过扩展代理类，进行一些功能的附加与增强。值得注意的是，代理类和被代理类应该共同实现一个接口，或者是共同继承某个类。</strong></p><h2 id="3-动态代理"><a href="#3-动态代理" class="headerlink" title="3. 动态代理"></a>3. 动态代理</h2><p>业务场景的复杂度往往千变万化，如果这个特别喜欢杏仁的客人，他也想在面包上撒一层杏仁，那我们怎么办？我们能够使用之前写的 ApricotCakeProxy 代理类么？不行，因为 ApricotCakeProxy 里规定了只能为蛋糕（实现了 CakeMachine 接口）的实体做代理。这种情况下，我们只能再写一个可以为所有面包加杏仁的代理类：ApricotBreadProxy。</p><pre><code class="hljs java"><span class="hljs-comment">//杏仁面包代理</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApricotBreadProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BreadMachine</span></span>&#123;    <span class="hljs-keyword">private</span> BreadMachine breadMachine;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ApricotBreadProxy</span><span class="hljs-params">(BreadMachine breadMachine)</span> </span>&#123;        <span class="hljs-keyword">this</span>.breadMachine = breadMachine;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeBread</span><span class="hljs-params">()</span> </span>&#123;        breadMachine.makeBread();        System.out.println(<span class="hljs-string">"adding apricot..."</span>);    &#125;&#125;<span class="hljs-comment">//蛋糕店</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CakeShop</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;          <span class="hljs-comment">//可以给各种各样的面包加上杏仁</span>        RedBeanBreadMachine redBeanBreadMachine = <span class="hljs-keyword">new</span> RedBeanBreadMachine();        ApricotBreadProxy apricotBreadProxy = <span class="hljs-keyword">new</span> ApricotBreadProxy(redBeanBreadMachine);        apricotBreadProxy.makeBread();        CurrantBreadMachine currantBreadMachine = <span class="hljs-keyword">new</span> CurrantBreadMachine();        apricotBreadProxy = <span class="hljs-keyword">new</span> ApricotBreadProxy(currantBreadMachine);        apricotBreadProxy.makeBread();    &#125;&#125;</code></pre><p>最终输出结果：</p><pre><code class="hljs java">making red bean bread....adding apricot...making currant bread...adding apricot...</code></pre><p>我们可以看到我们也成功地做出了客人想要的杏仁红豆面包、杏仁葡萄干面包。</p><p>对于客人来说，他肯定希望我们所有的产品都有一层杏仁，这样客人最喜欢了。为了满足客人的需求，那如果我们的产品有 100 种（饼干、酸奶等），我们是不是得写 100 个代理类呢？有没有一种方式可以让我们只写一次实现（撒杏仁的实现），但是任何类型的产品（蛋糕、面包、饼干、酸奶等）都可以使用呢？其实在 Java 中早已经有了针对这种情况而设计的一个接口，专门用来解决类似的问题，它就是<strong>动态代理 —— InvocationHandler。</strong></p><p><strong>动态代理与静态代理的区别是静态代理只能针对特定一种产品（蛋糕、面包、饼干、酸奶）做某种代理动作（撒杏仁），而动态代理则可以对所有类型产品（蛋糕、面包、饼干、酸奶等）做某种代理动作（撒杏仁）。</strong></p><p>接下来我们针对这个业务场景做一个代码的抽象实现。首先我们分析一下可以知道这种场景的共同点是希望在所有产品上都做「撒一层杏仁」的动作，所以我们就做一个杏仁动态代理（ApricotHandler）。</p><pre><code class="hljs java"><span class="hljs-comment">//杏仁动态代理</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApricotHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span></span>&#123;    <span class="hljs-keyword">private</span> Object object;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ApricotHandler</span><span class="hljs-params">(Object object)</span> </span>&#123;        <span class="hljs-keyword">this</span>.object = object;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        Object result = method.invoke(object, args);    <span class="hljs-comment">//调用真正的蛋糕机做蛋糕</span>        System.out.println(<span class="hljs-string">"adding apricot..."</span>);        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre><p>撒杏仁的代理写完之后，我们直接让蛋糕店开工：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CakeShop</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//动态代理(可以同时给蛋糕、面包等加杏仁)</span>        <span class="hljs-comment">//给蛋糕加上杏仁</span>        FruitCakeMachine fruitCakeMachine = <span class="hljs-keyword">new</span> FruitCakeMachine();        ApricotHandler apricotHandler = <span class="hljs-keyword">new</span> ApricotHandler(fruitCakeMachine);        CakeMachine cakeMachine = (CakeMachine) Proxy.newProxyInstance(fruitCakeMachine.getClass().getClassLoader(),                fruitCakeMachine.getClass().getInterfaces(),                apricotHandler);        cakeMachine.makeCake();        <span class="hljs-comment">//给面包加上杏仁</span>        RedBeanBreadMachine redBeanBreadMachine = <span class="hljs-keyword">new</span> RedBeanBreadMachine();        apricotHandler = <span class="hljs-keyword">new</span> ApricotHandler(redBeanBreadMachine);        BreadMachine breadMachine = (BreadMachine) Proxy.newProxyInstance(redBeanBreadMachine.getClass().getClassLoader(),                redBeanBreadMachine.getClass().getInterfaces(),                apricotHandler);        breadMachine.makeBread();    &#125;&#125;</code></pre><p>输出结果为：</p><pre><code class="hljs java">making a fruit cake...adding apricot...making red bean bread....adding apricot...</code></pre><p>从输出结果可以知道，这与我们想要的结果是一致的。与静态代理相比，动态代理具有更加的普适性，能减少更多重复的代码。试想这个场景如果使用静态代理的话，我们需要对每一种类型的蛋糕机都写一个代理类（ApricotCakeProxy、ApricotBreadProxy、ApricotCookieProxy等）。但是如果使用动态代理的话，我们只需要写一个通用的撒杏仁代理类（ApricotHandler）就可以直接完成所有操作了。直接省去了写 ApricotCakeProxy、ApricotBreadProxy、ApricotCookieProxy 的功夫，极大地提高了效率。</p><p>看到这里，大家应该清楚为什么有了静态代理之后，还需要有动态代理了吧。<strong>静态代理只能针对某一接口（面包 或 蛋糕）进行操作，如果要对所有接口都（所有产品）都能做一样操作，那就必须要动态代理出马了。</strong></p><h2 id="4-如何使用动态代理？"><a href="#4-如何使用动态代理？" class="headerlink" title="4. 如何使用动态代理？"></a>4. 如何使用动态代理？</h2><p>参照上面的例子，我们可以知道要实现动态代理需要做两方面的工作。</p><ul><li>必须新建一个类，并且这个类必须实现 <strong>InvocationHandler</strong> 接口。</li></ul><pre><code class="hljs java"><span class="hljs-comment">//杏仁动态代理</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApricotHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span></span>&#123;    <span class="hljs-keyword">private</span> Object object;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ApricotHandler</span><span class="hljs-params">(Object object)</span> </span>&#123;        <span class="hljs-keyword">this</span>.object = object;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        Object result = method.invoke(object, args);    <span class="hljs-comment">//调用真正的蛋糕机做蛋糕</span>        System.out.println(<span class="hljs-string">"adding apricot..."</span>);        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre><ul><li>在调用的时候使用 Proxy.newProxyInstance() 方法生成代理类。</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CakeShop</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//给蛋糕加上杏仁</span>        FruitCakeMachine fruitCakeMachine = <span class="hljs-keyword">new</span> FruitCakeMachine();        ApricotHandler apricotHandler = <span class="hljs-keyword">new</span> ApricotHandler(fruitCakeMachine);        CakeMachine cakeMachine = (CakeMachine) Proxy.newProxyInstance(fruitCakeMachine.getClass().getClassLoader(),                fruitCakeMachine.getClass().getInterfaces(),                apricotHandler);        cakeMachine.makeCake();&#125;</code></pre><ul><li>最后直接使用生成的代理类调用相关的方法即可。</li></ul><p>Tips:</p><pre><code class="hljs java"><span class="hljs-comment">/** </span><span class="hljs-comment">  * Proxy</span><span class="hljs-comment">  * 动态代理的语法</span><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> loader 自然是类加载器</span><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> interfaces 代码要用来代理的接口</span><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> h 一个InvocationHandler对象</span><span class="hljs-comment">  * <span class="hljs-doctag">@return</span> 代理对象</span><span class="hljs-comment">  */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">newProxyInstance</span><span class="hljs-params">(ClassLoader loader,</span></span><span class="hljs-function"><span class="hljs-params">                                          Class&lt;?&gt;[] interfaces,</span></span><span class="hljs-function"><span class="hljs-params">                                          InvocationHandler h)</span></span></code></pre><pre><code class="hljs java"><span class="hljs-comment">//InvocationHandler</span><span class="hljs-comment">//InvocationHandler 是一个接口，官方文档解释说，每个代理的实例都有一个与之关联的 InvocationHandler 实现类，如果代理的方法被调用，那么代理便会通知和转发给内部的 InvocationHandler 实现类，由它决定处理。</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment">  * 内部只是一个 invoke() 方法，正是这个方法决定了怎么样处理代理传递过来的方法调用。</span><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> proxy 代理对象</span><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> method 代理对象调用的方法</span><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> args 调用方法中的参数</span><span class="hljs-comment">  * <span class="hljs-doctag">@return</span> </span><span class="hljs-comment">  */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable</span>;&#125;</code></pre><h2 id="5-动态代理的几种实现方式"><a href="#5-动态代理的几种实现方式" class="headerlink" title="5. 动态代理的几种实现方式"></a>5. 动态代理的几种实现方式</h2><p>动态代理其实指的是一种设计模式概念，指的是通过代理来做一些通用的事情，常见的应用有权限系统、日志系统等，都用到了动态代理。</p><p>而 <strong>Java 动态代理只是动态代理的一种实现方式而已</strong>，动态代理还有另外一种实现方式，即 <strong>CGLib</strong>（Code Generation Library）。</p><p>Java 动态代理只能<strong>针对实现了接口的类进行拓展</strong>，所以细心的朋友会发现我们的代码里有一个叫 MachineCake 的接口。而 CGLib 则没有这个限制，因为 CGLib 是使用继承原有类的方式来实现代理的。</p><p>我们还是举个例子来说明 <strong>CGLib 是如何实现动态代理的</strong>吧。还是前面的例子：我们要做杏仁水果蛋糕、巧克力水果蛋糕、五仁巧克力蛋糕，这时候用代码描述是这样的。</p><p>首先我们需要写一个杏仁拦截器类，这个拦截器可以给做好的蛋糕加上杏仁。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApricotInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        methodProxy.invokeSuper(o, objects);        System.out.println(<span class="hljs-string">"adding apricot..."</span>);        <span class="hljs-keyword">return</span> o;    &#125;&#125;</code></pre><p>接着直接让蛋糕店使用 CGLib 提供的工具类做杏仁水果蛋糕：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CakeShop</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;         <span class="hljs-comment">//CGLib动态代理(可以同时给蛋糕、面包等加杏仁)</span>        Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();        enhancer.setSuperclass(FruitCakeMachine<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        enhancer.setCallback(<span class="hljs-keyword">new</span> ApricotInterceptor());        FruitCakeMachine fruitCakeMachine = (FruitCakeMachine) enhancer.create();        fruitCakeMachine.makeCake();    &#125;&#125;</code></pre><p>上面的 enhancer.setSuperClass() 设置需要增强的类，而 enhancer.setCallback() 则设置需要回调的拦截器，即实现了 MethodInterceptor 接口的类。最后最后使用 enhancer.create() 生成了对应的增强类，最后输出结果为：</p><pre><code class="hljs java">making a fruit cake...adding apricot...</code></pre><p>和我们预期的一样。如果要做一个杏仁面包片，那么直接让蛋糕店利用ApricotHandler 再做一个就可以了，它们的区别只是传入的增强类不同。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CakeShop</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;           <span class="hljs-comment">//做一个杏仁面包片</span>          Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();        enhancer.setSuperclass(RedBeanBreadMachine<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        enhancer.setCallback(<span class="hljs-keyword">new</span> ApricotInterceptor());        RedBeanBreadMachine chocolateCakeMachine = (RedBeanBreadMachine) enhancer.create();        chocolateCakeMachine.makeBread();    &#125;&#125;</code></pre><p>可以看到，这里传入的增强类是 RedBeanBreadMachine，而不是之前的 FruitCakeMachine。</p><p>对比 Java 动态代理和 CGLib 动态代理两种实现方式，你会发现 <strong>Java 动态代理适合于那些有接口抽象的类代理，而 CGLib 则适合那些没有接口抽象的类代理。</strong></p><h3 id="5-1-Java动态代理的原理"><a href="#5-1-Java动态代理的原理" class="headerlink" title="5.1. Java动态代理的原理"></a>5.1. Java动态代理的原理</h3><p>从上面的例子我们可以知道，Java 动态代理的入口是从 Proxy.newInstance() 方法中开始的，通过这个方法，Java 替我们生成了一个继承了指定接口（CakeMachine）的代理类（ApricotHandler）实例。Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) 方法简单来说执行了以下操作：</p><blockquote><p> 1、生成一个实现了参数 interfaces 里所有接口且继承了 Proxy 的代理类的字节码，然后用参数里的 classLoader 加载这个代理类。<br>2、使用代理类父类的构造函数 Proxy(InvocationHandler h) 来创造一个代理类的实例，将我们自定义的 InvocationHandler 的子类传入。<br>3、返回这个代理类实例，因为我们构造的代理类实现了 interfaces（也就是我们程序中传入的 fruitCakeMachine.getClass().getInterfaces() 里的所有接口，因此返回的代理类可以强转成 MachineCake 类型来调用接口中定义的方法。</p></blockquote><h3 id="5-2-CGLib动态代理的原理"><a href="#5-2-CGLib动态代理的原理" class="headerlink" title="5.2 CGLib动态代理的原理"></a>5.2 CGLib动态代理的原理</h3><p>因为 JVM 并不允许在运行时修改原有类，所以所有的动态性都是通过新建类来实现的，上面说到的 Java 动态代理也不例外。所以对于 CGLib 动态代理的原理，其实也是通过动态生成代理类，最后由代理类来完成操作实现的。</p><p>对于 CGLib 动态代理的实现，我并没有深入到源码中，而是通过查阅资料了解了其大概的实现原理。</p><ul><li>首先，我们在使用的时候通过 enhancer.setSuperclass(FruitCakeMachine.class) 传入了需要增加的类，CGLib 便会生成一个继承了该类的代理类。</li><li>接着，我们通过 enhancer.setCallback(new ApricotInterceptor()) 传入了代理类对象，CGLib 通过组装两个类的结构实现一个静态代理，从而达到具体的目的。</li></ul><p>而在 CGLib 生成新类的过程中，其使用的是一个名为 ASM 的东西，它对 Java 的 class 文件进行操作、生成新的 class 文件。如果你对 CGLib 的原理感兴趣，不妨看看这篇文章：<a href="https://www.zhihu.com/question/从兄弟到父子：动态代理在民间是怎么玩的？" target="_blank" rel="noopener">从兄弟到父子：动态代理在民间是怎么玩的？</a></p><h2 id="6-动态代理的应用"><a href="#6-动态代理的应用" class="headerlink" title="6. 动态代理的应用"></a>6. 动态代理的应用</h2><p>动态代理在代码界可是有非常重要的意义，我们开发用到的许多框架都使用到了这个概念。我所知道的就有：Spring AOP、Hibernate、Struts 使用到了动态代理。</p><ul><li><strong>Spring AOP。</strong>Spring 最重要的一个特性是 AOP（Aspect Oriented Programming 面向切面编程），利用 Spring AOP 可以快速地实现权限校验、安全校验等公用操作。而 Spring AOP 的原理则是通过动态代理实现的，默认情况下 Spring AOP 会采用 Java 动态代理实现，而当该类没有对应接口时才会使用 CGLib 动态代理实现。</li><li><strong>Hibernate。</strong>Hibernate 是一个常用的 ORM 层框架，在获取数据时常用的操作有：get() 和 load() 方法，它们的区别是：get() 方法会直接获取数据，而 load() 方法则会延迟加载，等到用户真的去取数据的时候才利用代理类去读数据库。</li><li><strong>Struts。</strong>Struts 现在虽然因为其太多 bug 已经被抛弃，但是曾经用过 Struts 的人都知道 Struts 中的拦截器。拦截器有非常强的 AOP 特性，仔细了解之后你会发现 Struts 拦截器其实也是用动态代理实现的。</li></ul><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>我们通过蛋糕店的不同业务场景介绍了静态代理和动态代理的应用，接着重点介绍了动态代理两种实现方式（Java 动态代理、CGLib 动态代理）的使用方法及其实现原理，其中还针对 Java 动态代理的源码进行了简单的分析。最后，我们介绍了动态代理在实际上编程中的应用（Spring AOP、Hibernate、Struts）。</p><p>希望这篇文章帮助大家更好地理解动态代理。</p><p>参考：<a href><a href="https://www.cnblogs.com/chanshuyi/p/deep_insight_java_proxy_pattern.html">Java动态代理：一个面包店的动态代理帝国</a></a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Learning</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java GC 知识小结</title>
    <link href="/2020/08/03/Java-GC%E5%B0%8F%E7%BB%93/"/>
    <url>/2020/08/03/Java-GC%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>Java GC相关知识小结，欢迎交流，指证错误。</p><a id="more"></a><h1 id="1-什么是垃圾？怎么寻找垃圾？"><a href="#1-什么是垃圾？怎么寻找垃圾？" class="headerlink" title="1. 什么是垃圾？怎么寻找垃圾？"></a>1. 什么是垃圾？怎么寻找垃圾？</h1><h2 id="1-1-什么是垃圾？"><a href="#1-1-什么是垃圾？" class="headerlink" title="1.1. 什么是垃圾？"></a>1.1. 什么是垃圾？</h2><blockquote><p><em>不再被引用的对象称为垃圾。</em></p></blockquote><h2 id="1-2-垃圾寻找方法（垃圾标记方法）："><a href="#1-2-垃圾寻找方法（垃圾标记方法）：" class="headerlink" title="1.2 . 垃圾寻找方法（垃圾标记方法）："></a>1.2 . 垃圾寻找方法（垃圾标记方法）：</h2><h3 id="1-2-1-引用计数算法（Reference-Counting）："><a href="#1-2-1-引用计数算法（Reference-Counting）：" class="headerlink" title="1.2.1.  引用计数算法（Reference Counting）："></a>1.2.1.  引用计数算法（Reference Counting）：</h3><p>介绍：给对象添加一个引用计数器，每当一个地方引用它时，计数器加1；当引用失效时，计数器减1；计数器为0的即可被回收。</p><blockquote><p>优点：实现简单，判断效率高。<br>缺点：存在循环引用（objA.instance = objB; objB.instance = objA）的问题，所以Java语言并没有选用引用计数法管理内存。</p></blockquote><h3 id="1-2-2-根搜索算法（GC-Root-Searching）"><a href="#1-2-2-根搜索算法（GC-Root-Searching）" class="headerlink" title="1.2.2. 根搜索算法（GC Root Searching）"></a>1.2.2. 根搜索算法（GC Root Searching）</h3><p>Java和C#都是使用根搜索算法来判断对象是否存活。通过一系列的名为“GC Root”的对象作为起始点，从这些节点开始向下搜索，搜索所有走过的路径称为引用链（Reference Chain）,当一个对象到GC Root没有任何引用链相连时（用图论来说就是GC Root到这个对象不可达时），证明该对象是可以被回收的。</p><blockquote><p>不存在循环引用问题。</p></blockquote><blockquote><p>在Java中哪些对象可以成为GC Root?</p><ul><li>虚拟机栈（栈帧中的本地变量表）中的引用对象</li><li>方法区中的类静态属性引用的对象</li><li>方法区中的常量引用对象</li><li>本地方法栈中JNI（即Native方法）的引用对象</li></ul></blockquote><h1 id="2-常见的垃圾收集算法有哪些？"><a href="#2-常见的垃圾收集算法有哪些？" class="headerlink" title="2. 常见的垃圾收集算法有哪些？"></a>2. 常见的垃圾收集算法有哪些？</h1><h2 id="2-1-标记清除-Mark-sweep"><a href="#2-1-标记清除-Mark-sweep" class="headerlink" title="2.1 标记清除(Mark-sweep)"></a>2.1 标记清除(Mark-sweep)</h2><p>这是垃圾收集算法中最基础的，根据名字就可以知道，它的思想就是标记那些要被回收的对象，然后统一回收。这种方法很简单，但是会有两个主要问题：</p><blockquote><ul><li>效率不高，标记和清除的效率都很低；</li><li>会产生大量不连续的内存碎片，导致以后程序在分配交大的对象时，由于没有充足的连续内存而提前触发一次GC动作。</li></ul></blockquote><h2 id="2-2-复制算法-Copying"><a href="#2-2-复制算法-Copying" class="headerlink" title="2.2. 复制算法(Copying)"></a>2.2. 复制算法(Copying)</h2><p>为了解决效率问题，复制算法将可用内存按容量划分相等的两部分，然后每次只使用其中的一块，当第一块内存用完时，就将还存活的对象复制到第二块内存上，然后一次性清除完第一块内存，在将第二块上的对象复制到第一块。但是这种方式，<strong>内存的代价太高，每次基本上都要浪费一块内存。</strong><br>于是将该算法进行了改进，内存区域不再是按照1：1去划分，而是将内存划分为8：1：1三部分，较大的那份内存叫Eden区，其余两块较小的内存叫Survior区。每次都会先使用Eden区，若Eden区满了，就将对象赋值到Survivor区上，然后清除Eden区，如果此时存活的对象太多，以至于Survivor不够时，会将这些对象通过分配担保机制赋值到老年代中。（Java堆又分为新生代和老年代）。</p><h2 id="2-3-标记-整理算法-Mark-Compact"><a href="#2-3-标记-整理算法-Mark-Compact" class="headerlink" title="2.3. 标记-整理算法(Mark-Compact)"></a>2.3. 标记-整理算法(Mark-Compact)</h2><p>该算法是为了<strong>解决标记-清除，产生大量内存碎片的问题</strong>；当对象存活率较高时，也解决了复制算法的效率问题。它的不同之处就是在清除对象的时候现将可回收的对象移动一端，然后清除掉端边界以外的对象，这样就不会产生内存碎片。</p><h2 id="2-4-分代收集算法（Generational-Collection）"><a href="#2-4-分代收集算法（Generational-Collection）" class="headerlink" title="2.4. 分代收集算法（Generational Collection）"></a>2.4. 分代收集算法（Generational Collection）</h2><p>根据对象的存活周期的不同将内存划分为几块，一般就分为新生代和老年代，根据各个年代的特点采用不同的收集算法。新生代（少量存活）用”复制算法“；老年代（对象存活率高）“标记-清除算法”。</p><h1 id="3-JVM运行时数据区"><a href="#3-JVM运行时数据区" class="headerlink" title="3. JVM运行时数据区"></a>3. JVM运行时数据区</h1><p>JVM运行时数据区如下图所示：</p><p><img src="https://gitee.com/yuanlu_k/BlogImages/raw/master/Java-GC%E5%B0%8F%E7%BB%93/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" srcset="/img/loading.gif" alt="JVM运行时数据区"></p><h2 id="3-1-堆"><a href="#3-1-堆" class="headerlink" title="3.1. 堆"></a>3.1. 堆</h2><ul><li>堆是Java虚拟机所管理的内存最大一块。堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域唯一的目的就是存放对象实例。所有的对象实例都在这里分配内存。<br>堆内存分为年轻代（Young Generation）、老年代（Old Generation），年轻代又分为Eden区和Survivor区。Survivor区由FromSpace和ToSpace组成。Eden区占大容量，Survivor两个区占小容量，默认比例是8:1:1。</li><li><strong>Java堆是垃圾收集器管理的主要区域。</strong></li><li>从内存回收的角度来看，由于现在的垃圾收集器采用的是分代收集算法。所以，Java堆又分为新生代和老年代。</li><li>从内存分配的角度来说，线程共享的Java堆中可能划分出多个线程私有的fenp缓冲区(Thread Local Allocation Buffer)。</li><li>可以通过 -Xms、-Xmx分别控制堆初始化是最小堆内存和最大堆内存大小</li></ul><h2 id="3-2-虚拟机栈"><a href="#3-2-虚拟机栈" class="headerlink" title="3.2. 虚拟机栈"></a>3.2. 虚拟机栈</h2><ul><li>与程序计数器一样，Java虚拟机栈也是线程私有的，他的生命周期与线程相同。</li><li>虚拟机栈描述的是Java方法的执行的内存模型：每个方法在执行的同时会创建一个栈桢（stack frame）用于存储<strong>局部变量表、操作数栈、动态链表、方法出口等信息</strong>。每个方法从调用直至执行完成的过程，就对应着栈桢在虚拟机栈中入栈到出栈的过程。</li><li>在虚拟机规范中，对这个区域规定了两种异常情况：StackOverflowError 和 OutOfMemorryError</li></ul><h2 id="3-3-本地方法栈"><a href="#3-3-本地方法栈" class="headerlink" title="3.3. 本地方法栈"></a>3.3. 本地方法栈</h2><ul><li>与虚拟机栈发挥的作用非常类似，他们之间的区别是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的native方法服务。与虚拟机栈一样，本地方法区栈也会抛出StackOverflowError，OutOfMemorryError异常。</li></ul><h2 id="3-4-方法区（1-8后该区域被废弃）"><a href="#3-4-方法区（1-8后该区域被废弃）" class="headerlink" title="3.4. 方法区（1.8后该区域被废弃）"></a>3.4. 方法区（1.8后该区域被废弃）</h2><ul><li>方法区与Java堆一样，是各个线程所共享的，它用来存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</li><li>方法区是jvm提出的规范，而永久代就是方法区的具体实现。</li><li>Java虚拟机对方法区的限制非常宽松，可以像堆一样不需要连续的内存可可选择的固定大小外，还可以选择不识闲垃圾收集，相对而言，垃圾收集行为在这边区域是比较少出现的。</li><li>在方法区会报出 永久代内存溢出的错误。而Java1.8为了解决这个问题，就提出了meta space（元空间）的概念，就是为了解决永久代内存溢出的情况，一般来说，在不指定 meta space大小的情况下，虚拟机方法区内存大小就是宿主主机的内存大小.</li></ul><h2 id="3-5-程序计数器"><a href="#3-5-程序计数器" class="headerlink" title="3.5. 程序计数器"></a>3.5. 程序计数器</h2><ul><li>程序计数器是一块较小的内存空间，他可以看做是当前线程所执行字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选择下一条将要执行的字节码指令。</li><li>由于JAVA虚拟机的多线程是通过多线程流转切换并分配处理器执行时间的方式来实现的。<strong>在任一一个确定的时刻，一个处理器都只会执行一条线程中的指令</strong>。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各个线程的计数器之间互不影响，独立存储，我们称该类内存区域为线程私有。</li><li>如果线程正在执行一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址。</li></ul><h2 id="3-6-运行时常量池"><a href="#3-6-运行时常量池" class="headerlink" title="3.6. 运行时常量池"></a>3.6. 运行时常量池</h2><ul><li>运行时常量池是方法区的一部分。Class文件除了有类的版本、字段、方法、接口等描述信息外，还有一项是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容在类加载后进入方法区的运行时常量池。</li><li>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性。Java语言并不要求常量一定只有在编译器才能产生，依旧是并非预置入Class文件中的常量池的内容才能进入方法区运行时常量池。</li></ul><h1 id="4-Java-GC的过程。"><a href="#4-Java-GC的过程。" class="headerlink" title="4. Java GC的过程。"></a>4. Java GC的过程。</h1><p><img src="https://gitee.com/yuanlu_k/BlogImages/raw/master/Java-GC%E5%B0%8F%E7%BB%93/javaGC%E8%BF%87%E7%A8%8B.png" srcset="/img/loading.gif" alt="Java GC过程"></p><blockquote><p>1、先判断创建的对象是否可以放入栈中，若可以的话，直接放入栈中，对象使用完后，直接从栈中pop即可，不涉及GC。<br>2、若不能放入栈中，判断对象所占内存是否太大，若对象太大，则直接放入堆中的老年代，最后通过FGC（Full GC）进行回收。<br>3、对象所占内存不算太大，经过TLAB（Thread Local Allocation Buffer）后放入Eden区。<br>4、在Eden区经过GC后，放入Survior1。<br>5、在Survior1中经历GC时，判断年龄是否太大，太大则将对象放入老年区。<br>6、年龄不大，则进入Survior2。<br>7、在Survior2中经历GC时，判断年龄是否太大，太大则将对象放入老年区。<br>8、年龄不大，则进入Survior1。<br>9、重复 5~8 。</p></blockquote><h1 id="5-垃圾回收所有算法。"><a href="#5-垃圾回收所有算法。" class="headerlink" title="5. 垃圾回收所有算法。"></a>5. 垃圾回收所有算法。</h1><blockquote><p>除Epsilon ZGC Shenandoah之外的GC都是使用逻辑分代模型<br>G1是逻辑分代，物理不分代<br>除此之外不仅逻辑分代，而且物理分代</p></blockquote><p><img src="https://gitee.com/yuanlu_k/BlogImages/raw/master/Java-GC%E5%B0%8F%E7%BB%93/allGC%E7%AE%97%E6%B3%95.png" srcset="/img/loading.gif" alt="所有GC算法"></p><p>上图是10种常见的垃圾回收算法。画弧线部分表示可以组合使用，图中黄线部分是最常见的3种组合。（<strong>STW ： Stop The World 非常严重的问题</strong>）</p><h2 id="5-1-Serial。"><a href="#5-1-Serial。" class="headerlink" title="5.1. Serial。"></a>5.1. Serial。</h2><p>在GC时，由单线程进行“清理”，其他线程（业务线程等）全部停止（STW）。</p><p><img src="https://gitee.com/yuanlu_k/BlogImages/raw/master/Java-GC%E5%B0%8F%E7%BB%93/Serial.png" srcset="/img/loading.gif" alt="Serial模型"></p><h2 id="5-2-Parallel-Scaven。"><a href="#5-2-Parallel-Scaven。" class="headerlink" title="5.2. Parallel Scaven。"></a>5.2. Parallel Scaven。</h2><p>在GC时由多线程进行“清理”，  其他线程（业务线程等）全部停止（STW）。  </p><p><img src="https://gitee.com/yuanlu_k/BlogImages/raw/master/Java-GC%E5%B0%8F%E7%BB%93/ParallelScaven.png" srcset="/img/loading.gif" alt="Parallel Scaven模型"></p><h2 id="5-3-Serial-Old。"><a href="#5-3-Serial-Old。" class="headerlink" title="5.3. Serial Old。"></a>5.3. Serial Old。</h2><p>用于老年代收集垃圾的单线程GC。</p><p><img src="https://gitee.com/yuanlu_k/BlogImages/raw/master/Java-GC%E5%B0%8F%E7%BB%93/SerialOld.png" srcset="/img/loading.gif" alt="Serial Old模型"></p><h2 id="5-4-ParNew。"><a href="#5-4-ParNew。" class="headerlink" title="5.4. ParNew。"></a>5.4. ParNew。</h2><p>与Parallel Scaven类似，但它可以与CMS配合使用。</p><p><img src="http://gitee.com/yuanlu_k/BlogImages/raw/master/Java-GC%E5%B0%8F%E7%BB%93/ParNew.png" srcset="/img/loading.gif" alt="ParNew模型"></p>]]></content>
    
    
    <categories>
      
      <category>Java learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo编写博客教程</title>
    <link href="/2020/08/01/Hexo%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/08/01/Hexo%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>这是我的第一篇博客，包含Hexo的基本使用，是一篇测试博客。</p><a id="more"></a><p>欢迎来到<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! 这是我编写的第一个博客。你可以通过查看<a href="https://hexo.io/docs/" target="_blank" rel="noopener">文档</a>来获取等多的信息。如果在使用Hexo过程中遇到任何为题，你可以通过<a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a>寻找解决方法，或者你可以在<a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>上向我提问。</p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="创建一个post-播客页面"><a href="#创建一个post-播客页面" class="headerlink" title="创建一个post(播客页面)"></a>创建一个post(播客页面)</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>更过<a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">博客编写信息</a>。</p><h3 id="启动Hexo-Server"><a href="#启动Hexo-Server" class="headerlink" title="启动Hexo Server"></a>启动Hexo Server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>有关<a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a>更多信息。</p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>关于<a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a>更多信息。</p><h3 id="部署到服务器站点"><a href="#部署到服务器站点" class="headerlink" title="部署到服务器站点"></a>部署到服务器站点</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>关于<a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a>更多信息。</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Learning</tag>
      
      <tag>Blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
